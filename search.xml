<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3 简单计算器(2)]]></title>
    <url>%2F2017%2F06%2F04%2FPython3-simple_calc_2%2F</url>
    <content type="text"><![CDATA[本文背景在我的上一篇博客，介绍了一个用Python递归函数与正则写的简单的计算器。刚写完那会儿，肯定还沉浸在那种自我陶醉的氛围当中；可夜深人静的时候，再回头去看那个程序；然后又重新尝试了一个表达式；发现竟然报错了！ 几乎完美主义者的我，眼睛容不得一微米的沙子；所以，趁着还年轻赶紧改了改。 不完美其实报错的原因是因为我正则写的不好。 之前的正则是这么写的 ​ r&#39;[^\(].*(\([^\)].*?\)).*&#39; 这个正则，使用了分组()。 匹配以非(到直到最后一个(开始分组了。 ​ 为什么是最后一个(；因为我使用了贪婪匹配.*。 然后继续匹配以非)到最近的一个)，然后结束分组。 ​ 为什么是最近的，因为我使用了非贪婪匹配.*? 匹配使用的是re.findall()方法，返回匹配到的分组。 这样的正则无法匹配以(的表达式；因为我写的是从非(开始；所以，考虑了再三；决定换一种思路去实现这个方法。 TO完美我的初衷是为了把表达式中的每个括号里面的内容提取出来（包含小括号），然后计算，替换回去。 最先提取出来的应该是最里层的括号。 那重新写正则，不考虑其他，就考虑匹配最里层括号里面的内容。 不管是否是以是什么开始，只匹配括号就行；经过测试与验证，可以得出如下正则： ​ r&#39;\([^()]+\)&#39; 这个正则就避免了开头是(无法匹配到的情况；我仍然使用re.findall()方法来将结果取出来并且循环去处理。 新版代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env python# coding:utf8# writen by Lisp at 2017/5/30# modified by Lisp at 2017/06/04"""实现简单的计算器用户输入: 1+(1+3)*3+3-(12/4)**(2-2/1) 1+3*3+3**2-2/1"""from __future__ import divisionimport redef my_calc(para_str): """ 处理整个字符串,用迭代依次取出最里面的小括号的内容,传给函数 my_calc1 去处理, 最后把原字符串替换为处理后的结果 :param para_str: 用户输入 :return: 最终结果 """ if ')' not in para_str: return my_calc1(para_str) else: # res = re.findall(r'[^\(].*(\([^\)].*?\)).*', para_str)[0] res = re.findall(r'\([^()]*\)', para_str) for each_par in res: para_str = para_str.replace(each_par, my_calc1(each_par.lstrip('(').rstrip(')'))) return my_calc(para_str)def chg_type(para_str): """ 这个函数用来转换字符串;如果字符串中有.,则转为float,否则转为int :param para_str: :return: """ if '.' in para_str: return float(para_str) else: return int(para_str)def self_math(x, y, f): """ 接收三个参数 :param x: 表达式左边 :param y: 表达式右边 :param f: 表达式中间的符号 :return: 返回结果,str类型 """ x, y, res = chg_type(x), chg_type(y), 0 if f == '+': res = x + y if f == '-': res = x - y if f == '*': res = x * y if f == '/': res = x / y if f == '**': res = x ** y return str(res)def math_ope(para_str): """ 这函数式处理字符串,把字符串分割,变为前中后三部分,传给self_math函数去计算,并返回str类型的结果 :param para_str: :return: """ para_str = str(para_str) temp_search = re.search(r'[0-9]\d*(\.\d+)?(?P&lt;flag&gt;[^\d].*?)[0-9]\d*(\.\d+)?', para_str) ope_flag = temp_search.group('flag') x, y = para_str.split(ope_flag) return self_math(x, y, ope_flag)def my_calc1(para_str): """ 按照列表中的优先级依次去循环迭代字符串 :param para_str: :return: """ while True: for item in all_com_list: rem = re.compile(r'(?P&lt;full&gt;[0-9]\d*(\.\d+)?&#123;&#125;[0-9]\d*(\.\d+)?)'.format(ope_dic[item])) if rem.search(para_str): exec(item + '_list' + '=' + str(rem.search(para_str).groupdict())) if eval(item + '_list'): each_item = eval(item + '_list')['full'] para_str = para_str.replace(each_item, str(math_ope(each_item))) if para_str.replace('.', '').isdigit(): break return para_strif __name__ == '__main__': # user_input = '1+(1+3)*3+3-(12/4)**(2-2/1)' user_input = '((24/2+3**2)*2)/((12-10/2)*(1+2/1-1)+1)+1.2' ope_dic = &#123; 'plus': '\+', 'less': '\-', 'mult': '\*', 'except': '/', 'power': '\*\*', &#125; all_com_list = ['power', 'mult', 'except', 'plus', 'less'] print(my_calc(user_input)) 一些说明 如果遇到了表达式中有空格的情况，那就优先处理；处理办法也很简单，以空格为分隔符，然后再用空连接起来就好了。 user_input = &#39;&#39;.join(user_input.split()) 如果有中括号的情况是无法满足的。 还有一些情况，比如小数后面的几位等等；这些也无法满足。 参考​ 正则工作室]]></content>
      <categories>
        <category>Python应用</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 简单计算器]]></title>
    <url>%2F2017%2F05%2F30%2FPython3-simple_calc%2F</url>
    <content type="text"><![CDATA[正则分析做题之前，我写了一个输入的字符串；看了5分钟，想了又想。 问题的关键之处在于，不管是否有什么运算符，永远是先算括号内的。 在有括号的情况下，只能先把括号内的东西给算出来。然后再去算另外一个括号内的东西。直到没有括号，再去调用自定义函数去做运算。 问题又来了，那先算哪个括号里的东西呢？我又想了1分钟，肯定是先算最里面括号的内容了。 OK，我知道怎么做了。 正则，匹配这个字符串中，最里面的那对括号。 然后把括号内的内容取出来。 计算括号内的内容 再替换回去 以此类推 上面的步骤，简直就可以用递归来做； 12345678910111213141516171819202122232425user_input = '1+(1+3)*3+3-(12/4)**(2-2/1)'user_input = '1+(1+3)*3+3-(12/4)**0.0'user_input = '1+(1+3)*3+3-3.0**0.0'user_input = '1+4*3+3-3.0**0.0'user_input = '1+4*3+3-3.0**0.0'# 到这里就要去循环按照优先级顺序把字符串中的运算式给计算出来并且替换为运算后的值user_input = '1+4*3+3-1.0'user_input = '1+12+3-1.0'user_input = '13+3-1.0'user_input = '13+2.0'user_input = '15.0'# ok , 结果出来了。# 注意；这里没有考虑中括号的情况。 实际代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #!/usr/bin/env python# coding:utf8# writen by Lisp at 2017/5/30 """实现简单的计算器用户输入: 1+(1+3)*3+3-(12/4)**(2-2/1)"""from __future__ import divisionimport redef my_calc(para_str): """ 处理整个字符串,用迭代依次取出最里面的小括号的内容,传给函数 my_calc1 去处理, 最后把原字符串替换为处理后的结果 :param para_str: 用户输入 :return: 最终结果 """ if ')' not in para_str: return my_calc1(para_str) else: res = re.findall(r'[^\(].*(\([^\)].*?\)).*', para_str)[0] return my_calc(para_str.replace(res, my_calc1(res.lstrip('(').rstrip(')'))))def chg_type(para_str): """ 这个函数用来转换字符串;如果字符串中有.,则转为float,否则转为int :param para_str: :return: """ if '.' in para_str: return float(para_str) else: return int(para_str)def self_math(x, y, f): """ 接收三个参数 :param x: 表达式左边 :param y: 表达式右边 :param f: 表达式中间的符号 :return: 返回结果,str类型 """ x, y, res = chg_type(x), chg_type(y), 0 if f == '+': res = x + y if f == '-': res = x - y if f == '*': res = x * y if f == '/': res = x / y if f == '**': res = x ** y return str(res)def math_ope(para_str): """ 这函数式处理字符串,把字符串分割,变为前中后三部分,传给self_math函数去计算,并返回str类型的结果 :param para_str: :return: """ para_str = str(para_str) temp_search = re.search(r'[0-9]\d*(\.\d+)?(?P&lt;flag&gt;[^\d].*?)[0-9]\d*(\.\d+)?', para_str) ope_flag = temp_search.group('flag') x, y = para_str.split(ope_flag) return self_math(x, y, ope_flag)def my_calc1(para_str): """ 按照列表中的优先级依次去循环迭代字符串 :param para_str: :return: """ while True: for item in all_com_list: exec(item + '_list' + '=' + str(re.findall(r'\d?\.?\d+&#123;&#125;\d?\.?\d+'.format(ope_dic[item]), para_str))) if eval(item + '_list'): each_item = eval(item + '_list')[0] para_str = para_str.replace(each_item, str(math_ope(each_item))) if para_str.replace('.', '').isdigit(): break return para_strif __name__ == '__main__': # user_input = input("请输入数学表达式: ") user_input = '1+(1+3)*3+3-(12/4)**(2-2/1)' ope_dic = &#123; 'plus': '\+', 'less': '\-', 'mult': '\*', 'except': '/', 'power': '\*\*', &#125; all_com_list = ['power', 'mult', 'except', 'plus', 'less'] print(my_calc(user_input)) 遇到的坑递归函数的时候，刚开始是这么写 123456def my_calc(para_str): if ')' not in para_str: return my_calc1(para_str) else: res = re.findall(r'[^\(].*(\([^\)].*?\)).*', para_str)[0] my_calc(para_str.replace(res, my_calc1(res.lstrip('(').rstrip(')')))) 然而，我后面print的结果竟然是None，当时我就懵逼了。。。 网上查了查资料，发现了一篇博客，也遇到了我的这个问题；瞬间明白了是怎么一回事。 因为你传入的参数，在函数体内，经过条件以后，并没有返回值；而是直接又调用了函数本身。只有当参数是不包含(的时候，才会有返回值；因此，正确的写法应该是在调用函数前面也加一个return。 练习心得 匹配整数或者是小数 可以用分组；把从小数后面的都用()括起来，然后用问号表示，匹配的要么是整数要么是小数 正则 `r&apos;[0-9]\d*(\.\d+)?(?P&lt;flag&gt;[^\d].*?)[0-9]\d*(\.\d+)?&apos;` 括号运算 没有中括号的情况下，小括号的运算级最高；因此优先处理小括号。 处理小括号一定要从最里层开始处理 递归 递归函数一定要注意写好返回值，以免出现None的情况.]]></content>
      <categories>
        <category>Python应用</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 修改Haproxy配置文件]]></title>
    <url>%2F2017%2F05%2F29%2Fmodified_haproxy_conf%2F</url>
    <content type="text"><![CDATA[查询根据域名来查询，这里的域名判断仅做(.)以及数字字母的处理，其他不做判断 比如位数，域名合法性等等 添加或更新根据backend来判断 不存在，直接更新，插入新记录 已存在，根据server来判断 不存在，直接插入新记录 已存在，直接更新 删除 走一遍select_pre，验证通过则判断用户输入的是域名走一遍add_pre，验证通过则判断用户输入的是json串 根据不同的情况， 判断 域名 根据backend判断 存在 - 直接清空 不存在 - 报错 json串 根据backend判断 存在backend，判断backend下是几条记录， 一条记录则清空（连带backend行业也删除） 多条记录则删除一条server记录 不存在backend，报错 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449#!/usr/bin/env python# coding:utf-8# modified by Lispdef get_cfg_content(): """ 读取配置文件内容，保存整个内容到列表 :return: list of all config content """ temp_list = [] with open(cfg_file, 'r') as r_f: for line in r_f: # all_cfg_list.append(line.strip()) # 保持原生状态 temp_list.append(line) return temp_listdef write_to_cfg(para_list): """ 将列表的内容重新写回配置文件 :param para_list: 更新后传过来的 all_cfg_list :return: """ with open(cfg_file, 'w+') as w_f: for w_line in para_list: w_f.writelines(w_line)def get_backend_server_dict(para_list): """ 根据all_cfg_list列表，得到backend下标和server的信息 &#123; 34: ['server 100.1.7.11 100.1.7.11 weight 20 maxconn 3000\n'], 27: ['server 100.1.7.8 100.1.7.8 weight 20 maxconn 3000\n', 'server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000\n'], 31: [' server 100.1.7.10 100.1.7.10 weight 20 maxconn 3000\n'] &#125; :param para_list: get_cfg_content 函数返回的列表 :return: dict """ # 返回的字典 temp_all_dic = &#123;&#125; # 迭代便利整个列表 for each_str in iter(para_list): # 如果列表中的元素以backend开头， if each_str.strip().startswith('backend'): # 记下下标 index_each_str = para_list.index(each_str) # 定义临时列表 temp_all_dic[index_each_str] = [] # 定义临时变量，目的是为了保留 当前backend的下标 n = index_each_str # 当前下标+1，循环 while n + 1 &lt; len(para_list): # 下一个下标，也就是backend下，第一个server的下标 next_each_str = para_list[n + 1] # 如果是以server开头 if str(next_each_str).strip().startswith('server'): # 添加到临时列表 temp_all_dic[index_each_str].append(next_each_str) # 否则就跳出while循环 else: break # 继续往下寻找 n += 1 # 返回 return temp_all_dicdef select_pre(u): """ 查询前的判断 :param u: 用户输入 :return: str """ # 不是字符串类型 if not isinstance(u, str): return '503' # 判断域名是否有足够的'.' if u.count('.') &lt; 2: return '504' # 两个.是否紧挨 if 'XX' in u.lower().replace('.', 'X'): return '505' # 开头结尾 if u.startswith('.') or u.endswith('.'): return '514' # 符合条件的 if u.replace('.', 'x').isalpha() or u.replace('.', 'x').isalnum(): return '400' # 否则 else: return '599'def add_pre(u): """ 添加前的判断 :param u: 用户输入 :return: str """ try: # 转换用户输入为dict u_dic = eval(u) # 判断是否包含这两个键 if 'backend' not in u_dic: return '501' if 'record' not in u_dic: return '502' # 如果有backend，则去select_pre继续判断，因为都是域名判断 judge_backend = select_pre(u_dic['backend']) if judge_backend != '500': return judge_backend # record 类型 是否为dict if not isinstance(u_dic['record'], dict): return '506' # 判断server, weight, maxconn 关键字 if 'server' not in u_dic['record']: return '507' if 'weight' not in u_dic['record']: return '508' if 'maxconn' not in u_dic['record']: return '509' # 判断值类型 if not isinstance(u_dic['record']['server'], str): return '510' if not isinstance(u_dic['record']['weight'], int): return '511' if not isinstance(u_dic['record']['maxconn'], int): return '512' if u_dic['record']['server'].count('.') &lt; 3: return '513' if isinstance(u_dic['record']['server'].replace('.', ''), int): return '513' if 'XX' in u_dic['record']['server'].replace('.', 'X'): return '513' return '500' except (SyntaxError, NameError, KeyError, TypeError): return '599'def del_pre(u): """ 删除前的判断 :param u: 用户输入 :return: str """ # 判断是否为域名 if select_pre(u) == '400': return '400' # 判断是否为json字符串 if add_pre(u) == '500': return '500' return '599'def get_user_input(*args): """ 各功能函数前,得到用户的输入,并且返回. 各功能主函数都有调用 :return: str """ # 提示语 uc_prompt = args[1] # 用户选择的功能ID uc_pre = args[0] while True: u = input(uc_prompt).strip() if u == '': continue # 根据用户输入的功能ID，匹配到字典的函数，去执行*_pre函数 gu = choice_dic[uc_pre](u) # 根据函数的返回，将结果返回给各功能函数 # 查询验证OK，返回400 if gu == '400': return u # 添加验证OK，返回500 elif gu == '500': return eval(u) # 验证不OK，返回报错信息，继续while循环 else: print(rt_dic[gu])def select_by_domain(uc='1', res_num=None, domain=None): """ 根据get_cfg_content 和 get_backend_server_dict查询，来判断打印出匹配记录 :param uc: 用户选择, 传给函数get_user_input参用 :param res_num: 添加或者删除完,调用select函数,传值,传添加的标志 :param domain: 默认为空,表示直接调用此函数; 否则为其他函数调用 :return: 无返回 """ # 拿刀所有内容列表，以及匹配到的backend和server的字典 all_cfg_list = get_cfg_content() bs_dic = get_backend_server_dict(all_cfg_list) # 如果是直接执行此函数 if domain is None: # 调用用户输入函数 domain = get_user_input(uc, prompt_dic[uc]) # 函数主程序区域 # 遍历字典的key，也就是每个backend的下标 for item in bs_dic: # 如果用户输入的域名存在这个backend行 if domain in all_cfg_list[item]: # 那么遍历 bs_dic 字典中对应 key 的 values ；是一个列表 for each_server in bs_dic[item]: print(each_server.strip()) # 下面的判断是为了给其它函数调用时带的参数 # 为空，表示函数自己，则执行默认查询结果 if res_num is None: print('\n&#123;&#125;成功, 总共&#123;&#125;条记录'.format(pt_dic[uc], len(bs_dic[item]))) # 删除函数传入删除成功标志 elif res_num == '8': print('\n&#123;&#125;成功，在已存在的backend下&lt;删除&gt;一条记录, 剩余&#123;&#125;条server记录'.format(pt_dic[uc], len(bs_dic[item]))) # 添加函数传入更新标志 elif res_num == '3': # 看似失败，其实是成功更新了 print('\n&#123;&#125;失败, 在已存在的backend下&lt;更新&gt;一条记录, 总共&#123;&#125;条server记录'.format(pt_dic[uc], len(bs_dic[item]))) # 添加函数传入添加新记录标志 elif res_num == '2': print('\n&#123;&#125;成功, 在已存在的backend下&lt;添加&gt;一条记录, 总共&#123;&#125;条server记录'.format(pt_dic[uc], len(bs_dic[item]))) # 添加函数传入新增记录标志 elif res_num == '1': print('\n&#123;&#125;成功, &lt;新增&gt;一个backend, 总共&#123;&#125;条server记录'.format(pt_dic[uc], len(bs_dic[item]))) # 跳出for循环，不执行else子句 break # 执行到这里，说明上面的子句没有break，意味着没有符合条件的域名 else: # 则根据其他函数传入的参数进行判断 # 删除函数，删除完调用如果走到else，表示已经清空 if res_num == '9': print('\n&#123;&#125;成功，已清空此域名的backend记录'.format(pt_dic[uc])) # 默认执行 else: print('\n&#123;&#125;失败，无此域名的记录'.format(pt_dic[uc]))def add_by_data(uc): """ 增加或者更新函数，根据get_cfg_content 和 get_backend_server_dict :param uc: 用户输入 :return: 无返回 """ # 传给 select_by_domain 函数的参数，用来匹配打印 # 1 无backend, 添加一个backend,一条server记录 # 2 有backend, 无要添加的server, 添加一条server # 3 有backend, 有要添加的server, 更新一条server add_flag = '1' all_cfg_list = get_cfg_content() bs_dic = get_backend_server_dict(all_cfg_list) # 本身就是字典，但是为了下面的代码，语法不警告，还是转一下 add_dic = dict(get_user_input(uc, prompt_dic[uc])) # 插入的server 行 字符串 server_str = '\tserver &#123;server&#125; &#123;server&#125; weight &#123;weight&#125; maxconn &#123;maxconn&#125;\n'.format_map(add_dic['record']) for item in bs_dic: if add_dic['backend'] in all_cfg_list[item]: # 要添加的域名已经存在配置文件 # 拿到要添加的server IP add_server_ip = add_dic['record']['server'] for each_ip in bs_dic[item]: # 如果已经存在此server,则直接更新 if add_server_ip in each_ip: # 更新all_cfg_list # 先拿到这个server在all_cfg_list中的下标, 再更新 update_index = bs_dic[item].index(each_ip) + item + 1 all_cfg_list[update_index] = server_str add_flag = '3' break else: add_index = item + len(bs_dic[item]) + 1 add_server_str = server_str all_cfg_list.insert(add_index, add_server_str) add_flag = '2' break else: # 不存在 # 直接插入到 最后一个backend 的最后一个server下面 # 获取最大的下标,也就是最后一个backend max_index = max(list(bs_dic.keys())) # 获取最后一个backend的 server个数 item_length = len(bs_dic[max_index]) # 得到最后一个server的下标 each_item = max_index + item_length # 要插入的空行下标 space_index = each_item + 1 # backend 行 下标 backend_index = each_item + 2 # server 行 下标 server_index = each_item + 3 # 空行下标 last_space = each_item + 4 # 插入的backend 行 字符串 backend_str = '&#123;&#125; &#123;&#125;\n'.format('backend', add_dic['backend'].strip()) # 插入 all_cfg_list.insert(space_index, '\n') all_cfg_list.insert(backend_index, backend_str) all_cfg_list.insert(server_index, server_str) all_cfg_list.insert(last_space, '\n') # 写入文件 write_to_cfg(all_cfg_list) select_by_domain(uc, res_num=add_flag, domain=add_dic['backend'])def del_by_data(uc): """ 删除整个backend, 需要用户输入域名; 删除单个server, 需要用户输入json :param uc: 用户输入 :return: 无返回 """ # 同add函数，传给 select 的打印标志 # 9 成功， 清空整个backend # 8 成功， 删除一个backend下的一个server del_flag = '' all_cfg_list = get_cfg_content() bs_dic = get_backend_server_dict(all_cfg_list) user_data = get_user_input(uc, prompt_dic[uc]) # 判断用户输入的是域名还是json串 if isinstance(user_data, dict): print('您选择了JSON串删除') user_data = dict(user_data) for each_backend in bs_dic: # 要删除的backend是否存在 if user_data['backend'] in all_cfg_list[each_backend]: # 存在此backend的server记录, 则再次确认要删除的IP是否存在bs_dic对应的list中 for each_server in bs_dic[each_backend]: if user_data['record']['server'] in each_server: # 判断此backend下是否只有一个server记录,如果只有1个,则连同backend也删除; 否则,只删除server if len(bs_dic[each_backend]) &gt; 1: # 只删除server记录 all_cfg_list.remove(each_server) del_flag = '8' else: # 删除backend和server all_cfg_list.remove(all_cfg_list[each_backend]) all_cfg_list.remove(each_server) del_flag = '9' break else: print('删除失败, backend下无server为&#123;&#125;的记录'.format(user_data['record']['server'])) break else: print('删除失败, 没有域名为 &#123;&#125; 的backend记录'.format(user_data['backend'])) # 写入文件 write_to_cfg(all_cfg_list) select_by_domain(uc, res_num=del_flag, domain=user_data['backend']) else: print('您选择了通过域名删除') user_data = str(user_data) for each_backend in bs_dic: # 要删除的backend是否存在 if user_data in all_cfg_list[each_backend]: print('存在backend,', user_data) # 存在则删除下面所有的记录 # 获得此backend下的server个数，以及server下标， 删除注意，从最大的下标开始删除；不会影响前面的下标。 # 循环pop for i in range(each_backend + len(bs_dic[each_backend]), each_backend - 1, -1): all_cfg_list.pop(i) del_flag = '9' break else: print('删除失败, 没有域名为 &#123;&#125; 的backend记录'.format(user_data)) # 写入文件 write_to_cfg(all_cfg_list) select_by_domain(uc, res_num=del_flag, domain=user_data)if __name__ == '__main__': # 行为字典，主功能函数 behavior_dic = &#123; '1': select_by_domain, '2': add_by_data, '3': del_by_data, &#125; # 提示字典，get_user_input 调用 prompt_dic = &#123; '1': '请输入要查询的域名 &gt;&gt;&gt; ', '2': '请输入要添加的数据 &gt;&gt;&gt; ', '3': '请输入要删除的数据 &gt;&gt;&gt; ', &#125; # 执行功能函数前的判断，get_user_input 调用 choice_dic = &#123; '1': select_pre, '2': add_pre, '3': del_pre, &#125; # print dic pt_dic = &#123; '1': '查询', '2': '添加', '3': '删除', &#125; # 判断结果 rt_dic = &#123; '501': '缺少backend关键字', '502': '缺少record关键字', '503': 'backend对应一个字符串', '504': 'backend的值中间应至少包含两个(.)', '505': 'backend的值输入不合法', '506': 'record对应一个字典', '507': '缺少server关键字', '508': '缺少weight关键字', '509': '缺少maxconn关键字', '510': 'server对应一个字符串', '511': 'weight对应一个整数', '512': 'maxconn对应一个整数', '513': 'server的值是一个IP', '514': '域名不能以(.)开头或结尾', '599': '参数无效，请重新输入', &#125; # main flag = True cfg_file = 'conf/haproxy.conf' print('''欢迎使用修改 HaProxy 配置文件脚本脚本包含以下功能: 1. 查询 --通过域名查询 2. 增加 --通过json字符串增加 3. 删除 --通过域名删除整个域名配置，或者通过json字符串删除域名下的某一配置 4. 退出''') while flag: try: user_choice = input('请输入功能编号 &gt;&gt; ').strip() except KeyboardInterrupt: flag = False if user_choice == '4': print('已退出!') flag = False continue if user_choice == '': continue if user_choice not in behavior_dic: print('输入无效,请输入功能编号!') continue behavior_dic[user_choice](user_choice) haproxy.conf12345678910111213141516171819202122232425262728293031323334353637383940414243globallog 127.0.0.1 local2daemonmaxconn 256log 127.0.0.1 local2 infodefaultslog globalmode httptimeout connect 5000mstimeout client 50000mstimeout server 50000msoption dontlognulllisten stats :8888stats enablestats uri /adminstats auth admin:1234frontend oldboy.orgbind 0.0.0.0:80option httplogoption httpcloseoption forwardforlog globalacl www hdr_reg(host) -i www.oldboy.orguse_backend www.oldboy.org if wwwbackend www.oldboy.org server 100.1.7.8 100.1.7.8 weight 20 maxconn 3000 server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000backend www.etiantian.org server 100.1.7.10 100.1.7.10 weight 20 maxconn 3000backend www.oldboyedu.org server 100.1.7.11 100.1.7.11 weight 20 maxconn 3000# 测试添加，不考虑haproxy的语法是否正确frontend oldboy.orgbind 0.0.0.0:80option httplogoption httpcloseoption forwardfor]]></content>
      <categories>
        <category>Python应用</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 初识迭代，迭代器，生成器]]></title>
    <url>%2F2017%2F05%2F23%2Fiter_and_generator%2F</url>
    <content type="text"><![CDATA[迭代与迭代器迭代有 `__iter__` 元子 迭代器有 `__iter__` 元子 有 `__next__` 元子 生成器 函数; 没有return, 被yield替代; 并且是被调用的函数, 如foo() &gt;&gt;&gt; 可以迭代的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 整形n1 = 123# 字符串s1 = '123'# 浮点型f1 = 12.3# 列表l1 = [1, 2, 3]# 元祖t1 = (1, 2, 3)# 字典d1 = &#123;'k1': 'v1', 'k2': 'v2'&#125;# 集合set1 = &#123;1, 2, 3&#125;# 文件with open('day04.py', 'r') as test_f: pass# 函数 passdef foo_pass(): pass# 函数def foo(): return True# 生成器函数def bar(): yield 1 yield 2# 函数包 生成器函数def foobar(): def bar1(): yield 1 return bar1()# # 插一句, 我曾经想用globals这个函数来去取出我上面定义的这些变量,结果发现没有成功.# print(locals() is globals())# 当前文件, locals() == globals()# 并且,在遍历一个字典的时候,是不可以对这个字典进行修改的.# 可以用copy方法, 来实现# vars_dic = globals().copy()# vars_list = []# for k in vars_dic:# if not k.startswith('_'):# vars_list.append(type(eval(k)))## print(vars_list)# 然而并没有什么卵用, 得到的是对象名, 像函数,我想得到其调用,则必须在后加上()才可.for i in n1, s1, f1, l1, t1, d1, set1, test_f, foo_pass, foo(), bar(), foobar(): i = type(i) if '__iter__' in dir(i): print('&#123;&#125;是可迭代的对象'.format(i)) else: print('&#123;&#125;不是可迭代的对象'.format(i)) if '__next__' in dir(i): print('&#123;&#125;是迭代器'.format(i)) else: print('&#123;&#125;不是迭代器'.format(i)) 结果如下： 123456789101112131415161718192021222324&lt;class 'int'&gt;不是可迭代的对象&lt;class 'int'&gt;不是迭代器&lt;class 'str'&gt;是可迭代的对象&lt;class 'str'&gt;不是迭代器&lt;class 'float'&gt;不是可迭代的对象&lt;class 'float'&gt;不是迭代器&lt;class 'list'&gt;是可迭代的对象&lt;class 'list'&gt;不是迭代器&lt;class 'tuple'&gt;是可迭代的对象&lt;class 'tuple'&gt;不是迭代器&lt;class 'dict'&gt;是可迭代的对象&lt;class 'dict'&gt;不是迭代器&lt;class 'set'&gt;是可迭代的对象&lt;class 'set'&gt;不是迭代器&lt;class '_io.TextIOWrapper'&gt;是可迭代的对象&lt;class '_io.TextIOWrapper'&gt;是迭代器&lt;class 'function'&gt;不是可迭代的对象&lt;class 'function'&gt;不是迭代器&lt;class 'bool'&gt;不是可迭代的对象&lt;class 'bool'&gt;不是迭代器&lt;class 'generator'&gt;是可迭代的对象&lt;class 'generator'&gt;是迭代器&lt;class 'generator'&gt;是可迭代的对象&lt;class 'generator'&gt;是迭代器 总结: 目前了解到的这些，除了生成器和文件是可以迭代的对象，而且还是迭代器以外；其他都只是可迭代对象。 可迭代对象都可以被iter()变为迭代器对象， 使用迭代器对象要比直接使用对象的迭代性高效的多，并且节省内存 遍历字典和列表等这种可变对象的时候，如果涉及到更改对象的值，需注意RuntimeError这个异常。 生成器是一个一次只返回一个值的特殊函数， 生成器函数一定是迭代器。 可以使用next()方法来拿到yield的值，也可使用__next__()特殊方法来查看。 使用for循环来解决生成器在最后出现的StopIteration异常。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 文件读写与函数]]></title>
    <url>%2F2017%2F05%2F16%2Ffile_and_func%2F</url>
    <content type="text"><![CDATA[文件读写open（P3推荐）一般都采用open方法打开文件， 打开文件句柄，将对象赋给变量 变量拥有操作文件的各种方法，可以去操作 关闭文件句柄 123456# 打开文件f = open('test.txt')# 读取# do something ...# 文件关闭f.close() with（上下文管理） 有了上下文管理，省略了文件在打开的时候因为异常或是因为忘记而导致出现文件未关闭的问题。 123with open("/tmp /foo.txt") as file: # do somethings data = file.read() with 的上下文用法可参考官网: https://docs.python.org/3/library/contextlib.html read(), readline(), readlines() read() 方法用于直接读取字节到字符串中，可以接参数给定最多读取的字节数，如果没有给定，则文件读取到末尾。 1234567891011$ cat /root/test.txtI'll write this message for youhehe,that's will be ok.&gt;&gt;&gt;&gt;fobj = open('/root/test.txt') ##默认已只读方式打开&gt;&gt;&gt;&gt;a = fobj.read()&gt;&gt;&gt;&gt;a"I'll write this message for you\nhehe,that's will be ok.\n" ##直接读取字节到字符串中,包括了换行符&gt;&gt;&gt;&gt; print aI'll write this message for youhehe,that's will be ok.&gt;&gt;&gt;&gt;fobj.close() readline() 方法读取打开文件的一行(读取下个行结束符之前的所有字节)，然后整行，包括行结束符，作为字符串返回。 12345678&gt;&gt;&gt;&gt; fobj = open('/root/test.txt')&gt;&gt;&gt;&gt;b = fobj.readline()&gt;&gt;&gt;&gt;b"I'll write this message for you\n" ##整行，包括行结束符，作为字符串返回&gt;&gt;&gt;&gt;c = fobj.readline()c&gt;&gt;&gt;&gt;"hehe,that's will be ok.\n" ##整行，包括行结束符，作为字符串返回&gt;&gt;&gt;&gt;fobj.close() readlines() 方法读取所有行，自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for ... in ... 结构进行处理 12345&gt;&gt;&gt;&gt;fobj = open('/root/test.txt')&gt;&gt;&gt;&gt; d = fobj.readlines()&gt;&gt;&gt;&gt;d["I'll write this message for you\n", "hehe,that's will be ok.\n"] ##读取所有行然后把它们作为一个字符串列表返回&gt;&gt;&gt;&gt;fobj.close() write(), writelines() write() 和read()、readline()方法相反，将字符串写入到文件中。 123456789101112131415161718&gt;&gt;&gt;&gt;fobj = open('/root/w_test.txt','w') ###确保/root/3.txt没有存在，如果存在，则会首先清空，然后写入。&gt;&gt;&gt;&gt;msg = ['write date','to w_test.txt','finish'] ###这里没有显式的给出换行符&gt;&gt;&gt;&gt;for m in msg:... fobj.write(m)...&gt;&gt;&gt;&gt;fobj.close()cat /root/w_test.txtwrite dateto w_test.txtfinish&gt;&gt;&gt;&gt;fobj = open('/root/w_test.txt','w') ###覆盖之前的数据&gt;&gt;&gt;&gt;msg = ['write date\n','to w_test.txt\n','finish\n'] ###显式给出换行符&gt;&gt;&gt;&gt;for m in msg:... fobj.write(m)...&gt;&gt;&gt;&gt;fobj.close()cat /root/w_test.txtwrite dateto w_test.txtfinish writelines() 针对列表的操作。它接收一个字符串列表作为参数，将他们写入到文件中，换行符不会自动的加入，因此，需要显式的加入换行符。 12345678&gt;&gt;&gt;&gt;fobj = open('/root/w_test.txt','w')&gt;&gt;&gt;&gt;msg = ['write date\n','to w_test.txt\n','finish\n']&gt;&gt;&gt;&gt;fobj.writelines(msg)&gt;&gt;&gt;&gt;fobj.close()cat /root/w_test.txtwrite dateto w_test.txtfinish 函数内建函数eval12345678910def eval(*args, **kwargs): # real signature unknown """ Evaluate the given source in the context of globals and locals. The source may be a string representing a Python expression or a code object as returned by compile(). The globals must be a dictionary and locals can be any mapping, defaulting to the current globals and locals. If only globals is given, locals defaults to it. """ exec1234567891011def exec(*args, **kwargs): # real signature unknown """ Execute the given source in the context of globals and locals. The source may be a string representing one or more Python statements or a code object as returned by compile(). The globals must be a dictionary and locals can be any mapping, defaulting to the current globals and locals. If only globals is given, locals defaults to it. """ pass divmoddef divmod(x, y): # known case of builtins.divmod """ Return the tuple ((x-x%y)/y, x%y). Invariant: div*y + mod == x. """ return (0, 0) [函数参数] 必备参数 关键字参数 默认参数 不定长参数 [自定义函数]函数规范-功能注释参考学习]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 集合方法总结]]></title>
    <url>%2F2017%2F05%2F12%2Fset_sum%2F</url>
    <content type="text"><![CDATA[clear| clear(...) | Remove all elements from this set. 作用: 清空集合，修改原集合 In [10]: s1 = {1, 2, 3, &apos;1,2,3&apos;, (&apos;Name&apos;,&apos;Pwd&apos;)} In [11]: s1 Out[11]: {1, 2, 3, &apos;1,2,3&apos;, (&apos;Name&apos;, &apos;Pwd&apos;)} In [12]: s1.clear() In [13]: s1 Out[13]: set() copy| copy(...) | Return a shallow copy of a set. 作用: 浅拷贝，返回一个和原集合一样的集合 In [14]: s1 = {1, 2, 3, &apos;1,2,3&apos;, (&apos;Name&apos;,&apos;Pwd&apos;)} In [15]: s1.copy() Out[15]: {1, 2, 3, &apos;1,2,3&apos;, (&apos;Name&apos;, &apos;Pwd&apos;)} difference| difference(...) | Return the difference of two or more sets as a new set. | | (i.e. all elements that are in this set but not the others.) 作用: 返回两个或两个以上集合中的不同，以集合方式返回。 In [17]: s1 = {1,2,3,4,5} In [18]: s2 = {3,1,2,12,21} In [19]: s1.difference(s2) Out[19]: {4, 5} In [20]: s2.difference(s1) Out[20]: {12, 21} In [21]: s3 = {2,1,3,12,33} In [22]: s1.difference(s2,s3) Out[22]: {4, 5} In [23]: s3.difference(s2,s1) Out[23]: {33} In [24]: s2.difference(s3,s1) Out[24]: {21} difference_update| difference_update(...) | Remove all elements of another set from this set. 作用: 在原集合中移除从另一个集合中能找到的元素，返回一个新集合 In [25]: s1 Out[25]: {1, 2, 3, 4, 5} In [26]: s2 Out[26]: {1, 2, 3, 12, 21} In [27]: s3 Out[27]: {1, 2, 3, 12, 33} In [28]: s1.difference_update(s2) In [29]: s1 Out[29]: {4, 5} discard| discard(...) | Remove an element from a set if it is a member. | | If the element is not a member, do nothing. 作用: 从set中移除一个元素，如果元素不再set中，则不用更改。 In [30]: s1 Out[30]: {4, 5} In [31]: s1.discard(1) In [32]: s1 Out[32]: {4, 5} In [33]: s1.discard(4) In [34]: s1 Out[34]: {5} intersection| intersection(...) | Return the intersection of two sets as a new set. | | (i.e. all elements that are in both sets.) 作用: 返回两个集合的交集 In [36]: s2 Out[36]: {1, 2, 3, 12, 21} In [37]: s3 Out[37]: {1, 2, 3, 12, 33} In [38]: s2.intersection(s3) Out[38]: {1, 2, 3, 12} In [39]: s2 Out[39]: {1, 2, 3, 12, 21} intersection_update| intersection_update(...) | Update a set with the intersection of itself and another. 作用: 更新交集到前面的集合中 In [40]: s2 Out[40]: {1, 2, 3, 12, 21} In [41]: s3 Out[41]: {1, 2, 3, 12, 33} In [42]: s2.intersection_update(s3) In [43]: s2 Out[43]: {1, 2, 3, 12} isdisjoint| isdisjoint(...) | Return True if two sets have a null intersection. 作用: 如果两个集合具有零交集，则返回True In [44]: s2 Out[44]: {1, 2, 3, 12} In [45]: s3 Out[45]: {1, 2, 3, 12, 33} In [46]: s2.isdisjoint(s3) Out[46]: False In [47]: s1 Out[47]: {5} In [48]: s1.isdisjoint(s2) Out[48]: True issubset| issubset(...) | Report whether another set contains this set. 作用: 返回前面的集合是否是另外一个集合的子集，返回布尔 In [55]: s2 Out[55]: {1, 2, 3, 12} In [56]: s4 Out[56]: {12} In [57]: s4.issubset(s2) Out[57]: True issuperset| issuperset(...) | Report whether this set contains another set. 作用: 返回后面的集合是否是前面集合的子集，返回布尔 In [60]: s2 Out[60]: {1, 2, 3, 12} In [61]: s4 Out[61]: {12} In [62]: s2.issuperset(s4) Out[62]: True In [63]: s3 Out[63]: {1, 2, 3, 12, 33} In [64]: s3.issuperset(s2) Out[64]: True pop| pop(...) | Remove and return an arbitrary set element. | Raises KeyError if the set is empty. 作用: 移除集合中的元素并且返回元素值，如果是空集合则会抛异常。 In [65]: s2 Out[65]: {1, 2, 3, 12} In [66]: s2.pop() Out[66]: 1 In [67]: s2 Out[67]: {2, 3, 12} remove| remove(...) | Remove an element from a set; it must be a member. | | If the element is not a member, raise a KeyError. 作用: 移除集合中的元素，如果不是集合中的成员，则会抛异常 In [68]: s2 Out[68]: {2, 3, 12} In [69]: s2.remove(3) In [70]: s2 Out[70]: {2, 12} In [71]: s2.remove(13) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-71-555029d6dce5&gt; in &lt;module&gt;() ----&gt; 1 s2.remove(13) KeyError: 13 symmetric_difference| symmetric_difference(...) | Return the symmetric difference of two sets as a new set. | | (i.e. all elements that are in exactly one of the sets.) 作用: 将两组集合的对称差作为新的集合返回 In [72]: s2 Out[72]: {2, 12} In [74]: s3 Out[74]: {1, 2, 3, 12, 33} In [75]: s2.symmetric_difference(s3) Out[75]: {1, 3, 33} symmetric_difference_update| symmetric_difference_update(...) | Update a set with the symmetric difference of itself and another. 作用: 将两组集合的对称差更新到前面的集合 In [72]: s2 Out[72]: {2, 12} In [74]: s3 Out[74]: {1, 2, 3, 12, 33} In [76]: s2.symmetric_difference_update(s3) In [79]: s2 Out[79]: {1, 3, 33} union| union(...) | Return the union of sets as a new set. | | (i.e. all elements that are in either set.) 作用: 返回两个集合的并集 In [80]: s2 Out[80]: {1, 3, 33} In [81]: s1 Out[81]: {5} In [82]: s1.union(s2) Out[82]: {1, 3, 5, 33} In [83]: s1 Out[83]: {5} In [84]: s2 Out[84]: {1, 3, 33} update| update(...) | Update a set with the union of itself and others. 作用: 更新集合，添加所有其他元素。 In [85]: s1 Out[85]: {5} In [86]: s2 Out[86]: {1, 3, 33} In [87]: s1.update(s2) In [88]: s1 Out[88]: {1, 3, 5, 33}]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 字典方法总结]]></title>
    <url>%2F2017%2F05%2F11%2Fdict_sum%2F</url>
    <content type="text"><![CDATA[clear| clear(...) | D.clear() -&gt; None. Remove all items from D. 作用: 清空原字典，返回None In [3]: dic1 = {&apos;k1&apos;:&apos;v1&apos;,&apos;name&apos;:&apos;Lisp&apos;} In [4]: dic1 Out[4]: {&apos;k1&apos;: &apos;v1&apos;, &apos;name&apos;: &apos;Lisp&apos;} In [5]: dic1.clear() In [6]: dic1 Out[6]: {} copy| copy(...) | D.copy() -&gt; a shallow copy of D 作用: 字典的浅拷贝，返回一个新字典 In [7]: dic1 = {&apos;k1&apos;:&apos;v1&apos;,&apos;name&apos;:&apos;Lisp&apos;} In [8]: dic1 Out[8]: {&apos;k1&apos;: &apos;v1&apos;, &apos;name&apos;: &apos;Lisp&apos;} In [9]: dic1.copy() Out[9]: {&apos;k1&apos;: &apos;v1&apos;, &apos;name&apos;: &apos;Lisp&apos;} fromkeys| fromkeys(iterable, value=None, /) from builtins.type | Returns a new dict with keys from iterable and values equal to value. 作用: dict的静态方法，返回一个字典。原字典不变 In [10]: dic2 = dict.fromkeys((&apos;1&apos;,&apos;1&apos;,&apos;23&apos;)) In [11]: dic2 Out[11]: {&apos;1&apos;: None, &apos;23&apos;: None} In [12]: dic2 = dict.fromkeys(&apos;12344444&apos;) In [13]: dic2 Out[13]: {&apos;1&apos;: None, &apos;2&apos;: None, &apos;3&apos;: None, &apos;4&apos;: None} In [14]: dic2 = dict.fromkeys(&apos;12344444&apos;, 3) In [15]: dic2 Out[15]: {&apos;1&apos;: 3, &apos;2&apos;: 3, &apos;3&apos;: 3, &apos;4&apos;: 3} get| get(...) | D.get(k[,d]) -&gt; D[k] if k in D, else d. d defaults to None. 作用: 如果键位于字典中，则返回键的值，否则返回默认值。 如果没有给出默认值，它将默认为None，因此此方法不会引发KeyError In [17]: dic2 Out[17]: {&apos;1&apos;: 3, &apos;2&apos;: 3, &apos;3&apos;: 3, &apos;4&apos;: 3} In [18]: dic2.get(&apos;2&apos;) Out[18]: 3 In [19]: dic2.get(&apos;2&apos;, 222) Out[19]: 3 In [20]: dic2.get(&apos;5&apos;) In [21]: dic2.get(&apos;5&apos;, 123) Out[21]: 123 items| items(...) | D.items() -&gt; a set-like object providing a view on D&apos;s items 作用: 返回一个dict_item，里面是键值二元组组成的列表 In [30]: dic2 Out[30]: {&apos;1&apos;: 3, &apos;2&apos;: 3, &apos;3&apos;: 3, &apos;4&apos;: 3} In [31]: for item in dic2.items(): ...: print(item) ...: (&apos;3&apos;, 3) (&apos;2&apos;, 3) (&apos;1&apos;, 3) (&apos;4&apos;, 3) In [32]: for k,v in dic2.items(): ...: print(k,v) ...: 3 3 2 3 1 3 4 3 keys| keys(...) | D.keys() -&gt; a set-like object providing a view on D&apos;s keys 作用: 返回一个dict_keys，里面是键组成的列表 In [34]: dic2 Out[34]: {&apos;1&apos;: 3, &apos;2&apos;: 3, &apos;3&apos;: 3, &apos;4&apos;: 3} In [35]: dic2.keys() Out[35]: dict_keys([&apos;3&apos;, &apos;2&apos;, &apos;1&apos;, &apos;4&apos;]) pop| pop(...) | D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. | If key is not found, d is returned if given, otherwise KeyError is raised 作用: 如果键在字典中，则将其删除并返回其值，否则返回默认值。 如果没有给出默认值，并且键不在字典中，则会引发KeyError。 In [36]: dic2 In [36]: dic2 Out[36]: {&apos;1&apos;: 3, &apos;2&apos;: 3, &apos;3&apos;: 3, &apos;4&apos;: 3} In [37]: dic2.pop(&apos;1&apos;) Out[37]: 3 In [39]: dic2 Out[39]: {&apos;2&apos;: 3, &apos;3&apos;: 3, &apos;4&apos;: 3} In [40]: dic2.pop(&apos;123&apos;,&apos;Null&apos;) Out[40]: &apos;Null&apos; In [41]: dic2.pop(&apos;123&apos;) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-41-74fa2f771472&gt; in &lt;module&gt;() ----&gt; 1 dic2.pop(&apos;123&apos;) KeyError: &apos;123&apos; popitem| popitem(...) | D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a | 2-tuple; but raise KeyError if D is empty. 作用: 从字典中删除并返回一个任意的（键值）对。二元组；随机删除，因为字典是无序的。 In [72]: dic2 Out[72]: {&apos;1&apos;: 2, &apos;123&apos;: 245, &apos;2&apos;: 3, &apos;4&apos;: 3} In [73]: dic2.popitem() Out[73]: (&apos;123&apos;, 245) In [74]: dic2 Out[74]: {&apos;1&apos;: 2, &apos;2&apos;: 3, &apos;4&apos;: 3} In [75]: dic2.popitem() Out[75]: (&apos;2&apos;, 3) In [76]: dic2 Out[76]: {&apos;1&apos;: 2, &apos;4&apos;: 3} setdefault| setdefault(...) | D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D 作用: 如果键在字典中，则返回其值。 如果没有，请插入具有默认值的键，并返回默认值。 默认默认为无。 In [77]: dic2 Out[77]: {&apos;1&apos;: 2, &apos;4&apos;: 3} In [78]: dic2.setdefault(&apos;1&apos;) Out[78]: 2 In [79]: dic2.setdefault(&apos;1&apos;,&apos;12&apos;) Out[79]: 2 In [80]: dic2 Out[80]: {&apos;1&apos;: 2, &apos;4&apos;: 3} In [81]: dic2.setdefault(&apos;11&apos;) In [82]: dic2 Out[82]: {&apos;1&apos;: 2, &apos;11&apos;: None, &apos;4&apos;: 3} In [83]: dic2.setdefault(&apos;112&apos;,&apos;ABC&apos;) Out[83]: &apos;ABC&apos; In [84]: dic2 Out[84]: {&apos;1&apos;: 2, &apos;11&apos;: None, &apos;112&apos;: &apos;ABC&apos;, &apos;4&apos;: 3} update| update(...) | D.update([E, ]**F) -&gt; None. Update D from dict/iterable E and F. | If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] | If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v | In either case, this is followed by: for k in F: D[k] = F[k] 作用: 用其他键/值对更新字典，覆盖现有键。 返回无。直接更新原字典 In [85]: dic2 Out[85]: {&apos;1&apos;: 2, &apos;11&apos;: None, &apos;112&apos;: &apos;ABC&apos;, &apos;4&apos;: 3} In [86]: dic1 Out[86]: {&apos;k1&apos;: &apos;v1&apos;, &apos;name&apos;: &apos;Lisp&apos;} In [87]: dic2.update(dic1) In [88]: dic2 Out[88]: {&apos;1&apos;: 2, &apos;11&apos;: None, &apos;112&apos;: &apos;ABC&apos;, &apos;4&apos;: 3, &apos;k1&apos;: &apos;v1&apos;, &apos;name&apos;: &apos;Lisp&apos;} In [89]: dic1[&apos;k1&apos;]=&apos;Love&apos; In [90]: dic1 Out[90]: {&apos;k1&apos;: &apos;Love&apos;, &apos;name&apos;: &apos;Lisp&apos;} In [91]: dic2.update(dic1) In [92]: dic2 Out[92]: {&apos;1&apos;: 2, &apos;11&apos;: None, &apos;112&apos;: &apos;ABC&apos;, &apos;4&apos;: 3, &apos;k1&apos;: &apos;Love&apos;, &apos;name&apos;: &apos;Lisp&apos;} values| values(...) | D.values() -&gt; an object providing a view on D&apos;s values 作用: 与keys类似，返回一个dict_values。包含了所有值的列表 In [93]: dic2 Out[93]: {&apos;1&apos;: 2, &apos;11&apos;: None, &apos;112&apos;: &apos;ABC&apos;, &apos;4&apos;: 3, &apos;k1&apos;: &apos;Love&apos;, &apos;name&apos;: &apos;Lisp&apos;} In [94]: dic2.values() Out[94]: dict_values([&apos;Lisp&apos;, None, &apos;ABC&apos;, 2, 3, &apos;Love&apos;])]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 列表方法总结]]></title>
    <url>%2F2017%2F05%2F10%2Flist_sum%2F</url>
    <content type="text"><![CDATA[append| append(...) | L.append(object) -&gt; None -- append object to end 作用: 原列表新加元素，返回值为None。直接更新原list In [1]: l1 = [&apos;a&apos;, 1, &apos;b&apos;, 2] In [2]: l1.append((&apos;a&apos;,&apos;b&apos;)) In [3]: l1 Out[3]: [&apos;a&apos;, 1, &apos;b&apos;, 2, (&apos;a&apos;, &apos;b&apos;)] clear| clear(...) | L.clear() -&gt; None -- remove all items from L 作用: 清空原列表，返回值为None。 In [5]: l1 Out[5]: [&apos;a&apos;, 1, &apos;b&apos;, 2, (&apos;a&apos;, &apos;b&apos;), 2] In [6]: l1.clear() In [7]: l1 Out[7]: [] copy| copy(...) | L.copy() -&gt; list -- a shallow copy of L 作用: 拷贝一份原列表，返回一个新的列表；浅拷贝 In [8]: l1 = [&apos;1,2&apos;,2,(&apos;1&apos;,2),{&apos;k1&apos;:&apos;v1&apos;,&apos;k2&apos;:&apos;v2&apos;}] In [9]: l1 Out[9]: [&apos;1,2&apos;, 2, (&apos;1&apos;, 2), {&apos;k1&apos;: &apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;}] In [10]: l1.copy() Out[10]: [&apos;1,2&apos;, 2, (&apos;1&apos;, 2), {&apos;k1&apos;: &apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;}] count| count(...) | L.count(value) -&gt; integer -- return number of occurrences of value 作用： 计算列表中的元素个数 In [16]: l1 = [1,2,3,4,5,1,2,1,2,3,1,2,2,1,2,3] In [18]: l1.count(1) Out[18]: 5 In [19]: l1.count(2) Out[19]: 6 In [20]: l1.count(&apos;2&apos;) Out[20]: 0 extend| extend(...) | L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable 作用: 扩展原列表，返回值为空 In [22]: l1 Out[22]: [&apos;1&apos;, 2, &apos;3&apos;, &apos;3&apos;, &apos;4&apos;] In [24]: l1.extend(&apos;12345&apos;) In [26]: l1 Out[26]: [&apos;1&apos;, 2, &apos;3&apos;, &apos;3&apos;, &apos;4&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;] In [27]: l1.extend((&apos;1&apos;,&apos;2&apos;,&apos;123&apos;)) In [28]: l1 Out[28]: [&apos;1&apos;, 2, &apos;3&apos;, &apos;3&apos;, &apos;4&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;1&apos;, &apos;2&apos;, &apos;123&apos;] index| index(...) | L.index(value, [start, [stop]]) -&gt; integer -- return first index of value. | Raises ValueError if the value is not present. 作用: 返回列表中第一个元素的下标，如果没有则抛异常 In [29]: l1 Out[29]: [&apos;1&apos;, 2, &apos;3&apos;, &apos;3&apos;, &apos;4&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;1&apos;, &apos;2&apos;, &apos;123&apos;] In [30]: l1.index(2) Out[30]: 1 In [31]: l1.index(&apos;2&apos;) Out[31]: 6 In [32]: l1.index(&apos;12&apos;) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-32-e63f225f10b3&gt; in &lt;module&gt;() ----&gt; 1 l1.index(&apos;12&apos;) ValueError: &apos;12&apos; is not in list insert| insert(...) | L.insert(index, object) -- insert object before index 作用： 插入一个元素，在指定的下标前 In [33]: l1 = [&apos;1&apos;,&apos;b&apos;,&apos;c&apos;] In [35]: l1.insert(2,&apos;Lisp&apos;) In [36]: l1 Out[36]: [&apos;1&apos;, &apos;b&apos;, &apos;Lisp&apos;, &apos;c&apos;] pop| pop(...) | L.pop([index]) -&gt; item -- remove and return item at index (default last). | Raises IndexError if list is empty or index is out of range. 作用: 将列表的最后一个元素弹出，原列表不存在，并且返回元素值。可以指定移除的元素下标；如果列表为空或者元素不存在，则报错。 In [37]: l1 Out[37]: [&apos;1&apos;, &apos;b&apos;, &apos;Lisp&apos;, &apos;c&apos;] In [38]: l1.pop(1) Out[38]: &apos;b&apos; In [39]: l1 Out[39]: [&apos;1&apos;, &apos;Lisp&apos;, &apos;c&apos;] In [40]: l1.pop() Out[40]: &apos;c&apos; In [41]: l1 Out[41]: [&apos;1&apos;, &apos;Lisp&apos;] In [42]: l1.pop(2) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-42-5baeb30fb937&gt; in &lt;module&gt;() ----&gt; 1 l1.pop(2) IndexError: pop index out of range In [43]: l1.pop() Out[43]: &apos;Lisp&apos; In [44]: l1.pop() Out[44]: &apos;1&apos; In [45]: l1.pop() --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-45-fe7b19d1243e&gt; in &lt;module&gt;() ----&gt; 1 l1.pop() IndexError: pop from empty list remove| remove(...) | L.remove(value) -&gt; None -- remove first occurrence of value. | Raises ValueError if the value is not present. 作用: 移除列表中匹配到第一个value的元素，如果value不存在，则报异常；无返回 In [50]: l1 Out[50]: [&apos;1&apos;, &apos;b&apos;, &apos;Lisp&apos;, &apos;Lisp&apos;, &apos;c&apos;] In [51]: l1.remove(1) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-51-a2ee4bab7918&gt; in &lt;module&gt;() ----&gt; 1 l1.remove(1) ValueError: list.remove(x): x not in list In [52]: l1.remove(&apos;1&apos;) In [53]: l1 Out[53]: [&apos;b&apos;, &apos;Lisp&apos;, &apos;Lisp&apos;, &apos;c&apos;] In [54]: l1.remove(&apos;Lisp&apos;) In [55]: l1 Out[55]: [&apos;b&apos;, &apos;Lisp&apos;, &apos;c&apos;] reverse| reverse(...) | L.reverse() -- reverse *IN PLACE* 作用: 反转原列表，返回值为空 In [57]: l1 Out[57]: [&apos;b&apos;, &apos;Lisp&apos;, &apos;c&apos;] In [59]: l1.reverse() In [60]: l1 Out[60]: [&apos;c&apos;, &apos;Lisp&apos;, &apos;b&apos;] sort| sort(...) | L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* 作用: 将原列表排序，无返回 In [63]: l1 Out[63]: [&apos;c&apos;, &apos;Lisp&apos;, &apos;b&apos;] In [64]: l1.sort() In [65]: l1 Out[65]: [&apos;Lisp&apos;, &apos;b&apos;, &apos;c&apos;] In [66]: l1.append(&apos;1234&apos;) In [67]: l1 Out[67]: [&apos;Lisp&apos;, &apos;b&apos;, &apos;c&apos;, &apos;1234&apos;] In [70]: l1.sort() In [71]: l1 Out[71]: [&apos;1234&apos;, &apos;Lisp&apos;, &apos;b&apos;, &apos;c&apos;] 列表方法总结 append 直接追加原列表，返回None clear 直接清空原列表，返回None extend 直接扩展原列表，返回None insert 直接插入原列表，返回None pop 直接更新原列表，返回弹出的元素值；根据下标弹出 remove 直接更新原列表，返回None reverse 直接翻转原列表，返回None sort 直接将原列表排序，返回None copy 复制原列表，返回新列表 index 返回第一次匹配到的元素下标，返回整型 count 计算元素在列表中出现的次]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 字符串方法总结]]></title>
    <url>%2F2017%2F05%2F08%2Fstr_sum%2F</url>
    <content type="text"><![CDATA[capitalize| capitalize(...) | S.capitalize() -&gt; str # 返回一个字符串 | | Return a capitalized version of S, i.e. make the first character | have upper case and the rest lower case. capitalized word意思为字首大写的单词。 作用: 将字符串的首字符大写，其他转为小写。 In [1]: str1 = &apos;lisp&apos; In [2]: str1.capitalize() Out[2]: &apos;Lisp&apos; In [3]: str1 = &apos;liSp&apos; In [4]: str1.capitalize() Out[4]: &apos;Lisp&apos; In [5]: str1 = &apos;1liSp&apos; In [6]: str1.capitalize() Out[6]: &apos;1lisp&apos; casefold| casefold(...) | S.casefold() -&gt; str # 返回一个字符串 | | Return a version of S suitable for caseless comparisons. 作用: 将字符串的全部变为小写。 In [35]: str1 = &apos;I\&apos;m Lisp. Life is short, I use Python!&apos; In [36]: str1.casefold() Out[36]: &quot;i&apos;m lisp. life is short, i use python!&quot; center| center(...) | S.center(width[, fillchar]) -&gt; str # 返回一个字符串，中括号的参数表示填充字符可选，默认是一个空格 | | Return S centered in a string of length width. Padding is | done using the specified fill character (default is a space) 作用: 将字符串居中显示，可选择填充的单字符。 In [1]: str1 = &apos;lisp&apos; In [2]: str1.center(10) Out[2]: &apos; lisp &apos; In [3]: str1.center(10,&apos;2&apos;) Out[3]: &apos;222lisp222&apos; In [4]: str1.center(10,&apos;Py&apos;) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-4-d7c6560d7f7f&gt; in &lt;module&gt;() ----&gt; 1 str1.center(10,&apos;Py&apos;) TypeError: The fill character must be exactly one character long count| count(...) | S.count(sub[, start[, end]]) -&gt; int # 返回一个整数，中括号的参数表示可选，不选表示[0:) | # start 表示起始寻址位置 | # end 表示终点寻址位置（不包含） | | Return the number of non-overlapping occurrences of substring sub in | string S[start:end]. Optional arguments start and end are | interpreted as in slice notation. 作用: 计算子字符串在字符串中出现的个数，可以设置寻找的起始位置和终止位置。 In [28]: str1 = &apos;lishaopeng 666, he is a Pythoner, 666&apos; In [29]: str1.count(&apos;n&apos;) Out[29]: 2 In [30]: str1.count(&apos;6&apos;) Out[30]: 6 In [31]: str1.count(&apos;66&apos;) Out[31]: 2 In [32]: str1.count(&apos;6&apos;,12) Out[32]: 5 In [33]: str1.count(&apos;6&apos;,12,15) Out[33]: 2 In [34]: str1.count(&apos;6&apos;,-3) Out[34]: 3 In [35]: str1.count(&apos;6&apos;,-3,-1) Out[35]: 2 In [36]: str1.count(&apos;9&apos;) Out[36]: 0 encode| encode(...) | S.encode(encoding=&apos;utf-8&apos;, errors=&apos;strict&apos;) -&gt; bytes | | Encode S using the codec registered for encoding. Default encoding | is &apos;utf-8&apos;. errors may be given to set a different error | handling scheme. Default is &apos;strict&apos; meaning that encoding errors raise | a UnicodeEncodeError. Other possible values are &apos;ignore&apos;, &apos;replace&apos; and | &apos;xmlcharrefreplace&apos; as well as any other name registered with | codecs.register_error that can handle UnicodeEncodeErrors. 作用: 字符串转换，默认转成UTF-8 In [45]: str1 = &apos;人生苦短，我用Python&apos; In [46]: str1 Out[46]: &apos;人生苦短，我用Python&apos; In [47]: str1.encode() Out[47]: b&apos;\xe4\xba\xba\xe7\x94\x9f\xe8\x8b\xa6\xe7\x9f\xad\xef\xbc\x8c\xe6\x88\x91\xe7\x94\xa8Python&apos; In [48]: str1.encode(encoding=&apos;utf-8&apos;) Out[48]: b&apos;\xe4\xba\xba\xe7\x94\x9f\xe8\x8b\xa6\xe7\x9f\xad\xef\xbc\x8c\xe6\x88\x91\xe7\x94\xa8Python&apos; In [49]: str1.encode(encoding=&apos;GBK&apos;) Out[49]: b&apos;\xc8\xcb\xc9\xfa\xbf\xe0\xb6\xcc\xa3\xac\xce\xd2\xd3\xc3Python&apos; In [50]: str1.encode(encoding=&apos;GBK&apos;).decode() --------------------------------------------------------------------------- UnicodeDecodeError Traceback (most recent call last) &lt;ipython-input-50-1b0fa5bac7bf&gt; in &lt;module&gt;() ----&gt; 1 str1.encode(encoding=&apos;GBK&apos;).decode() UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xc8 in position 0: invalid continuation byte In [51]: str1.encode(encoding=&apos;GBK&apos;).decode(encoding=&apos;GBK&apos;) Out[51]: &apos;人生苦短，我用Python&apos; endswith| endswith(...) | S.endswith(suffix[, start[, end]]) -&gt; bool # 返回布尔类型，中括号的参数表示可选，不选表示[0:) | # start 表示起始寻址位置 | # end 表示终点寻址位置（不包含） | | Return True if S ends with the specified suffix, False otherwise. | With optional start, test S beginning at that position. | With optional end, stop comparing S at that position. | suffix can also be a tuple of strings to try. 作用: 返回True或者False, 判断字符串是否以suffix结尾 In [7]: str1 = &apos;This is my bois&apos; In [8]: str1.endswith(&apos;bois&apos;) Out[8]: True In [9]: str1.endswith(&apos;is&apos;, 2, 3) Out[9]: False In [10]: str1.endswith(&apos;is&apos;, 2, 4) Out[10]: True In [11]: str1.endswith(&apos;is&apos;, 2, 6) Out[11]: False In [12]: str1.endswith(&apos;is&apos;, 2, 7) Out[12]: True expandtabs | expandtabs(...) | S.expandtabs(tabsize=8) -&gt; str # 返回字符串 | | Return a copy of S where all tab characters are expanded using spaces. | If tabsize is not given, a tab size of 8 characters is assumed. def expandtabs(string, n): result = &quot;&quot; pos = 0 for char in string: if char == &quot;\t&quot;: # instead of the tab character, append the # number of spaces to the next tab stop char = &quot; &quot; * (n - pos % n) if char == &quot;\n&quot;: pos = 0 else: pos += len(char) result += char return result 作用: 将字符串中的制表符替换为等宽长度的空格,默认8个空格;可以指定. In [21]: str1 = &apos;Life\tis\tshort\t\tI\tuse\tPython&apos; In [22]: str1.expandtabs() Out[22]: &apos;Life is short I use Python&apos; In [23]: str1 = &apos;AppName\tAppPort\tAppPid\nSMFWebApp\t8081\t19201\nSMFTrade\t8082\t12758\nSMFServices\t8083\t16731&apos; In [24]: print(str1.expandtabs(16)) AppName AppPort AppPid SMFWebApp 8081 19201 SMFTrade 8082 12758 SMFServices 8083 16731 默认tabsize=8 \t前，不足8位，\t补8-len(char)个空格； \t前，刚好8位，\t补8个空格； \t前，超过8位，\t补8-len(char)%8个空格 In [35]: str1 = &apos;abc\td\tef\thijk\tlmnop\t&apos; In [36]: str1.expandtabs(4) Out[36]: &apos;abc d ef hijk lmnop &apos; In [37]: str1.expandtabs(4).replace(&apos; &apos;, &apos;*&apos;) Out[37]: &apos;abc*d***ef**hijk****lmnop***&apos; find| find(...) | S.find(sub[, start[, end]]) -&gt; int # 返回整型 | # start 表示起始寻址位置 | # end 表示终点寻址位置（不包含） | | Return the lowest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Return -1 on failure. 作用: 查找字符串中是否包含子字符串;如果包含子字符串返回开始的索引值，否则返回-1。 In [8]: str1 = &apos;abcdeabcdeabc&apos; In [9]: str1.find(&apos;ab&apos;) Out[9]: 0 In [10]: str1.find(&apos;bcde&apos;) Out[10]: 1 In [11]: str1.find(&apos;bc&apos;,4) Out[11]: 6 In [12]: str1.find(&apos;bc&apos;,4,5) Out[12]: -1 format| format(...) | S.format(*args, **kwargs) -&gt; str # 返回字符串 | | Return a formatted version of S, using substitutions from args and kwargs. | The substitutions are identified by braces (&apos;{&apos; and &apos;}&apos;). 作用: 格式化字符串,可以指定位置,指定参数.可以传元祖,列表,也可以传字典. In [18]: str1 = &apos;{}在老男孩教育学{}&apos;.format(&apos;李少鹏&apos;, &apos;Python&apos;) In [19]: str1 Out[19]: &apos;李少鹏在老男孩教育学Python&apos; In [20]: str1 = &apos;{0}在老男孩教育学{1}&apos;.format(&apos;Lisp&apos;, &apos;Python&apos;) In [21]: str1 Out[21]: &apos;Lisp在老男孩教育学Python&apos; In [22]: str1 = &apos;{1}在老男孩教育学{0}&apos;.format(&apos;Python&apos;, &apos;Lisp&apos;) In [23]: str1 Out[23]: &apos;Lisp在老男孩教育学Python&apos; In [24]: user_tuple = (&apos;李少鹏&apos;, &apos;Python&apos;) In [25]: str1 = &apos;{}在老男孩教育学{}&apos;.format(*user_tuple) In [26]: str1 Out[26]: &apos;李少鹏在老男孩教育学Python&apos; In [27]: user_dict = {&apos;name&apos;:&apos;李少鹏&apos;,&apos;study&apos;:&apos;Python&apos;} In [28]: str1 = &apos;{name}在老男孩教育学{study}&apos;.format(**user_dict) In [29]: str1 Out[29]: &apos;李少鹏在老男孩教育学Python&apos; format_map| format_map(...) | S.format_map(mapping) -&gt; str # 返回字符串 | | Return a formatted version of S, using substitutions from mapping. | The substitutions are identified by braces (&apos;{&apos; and &apos;}&apos;). 作用: 与format(**mapping)类似, 但区别是,在调用dict的时候,format会去copy一份dict,产生一个新的dict;而format_map是直接引用 format_map允许您使用具有特殊行为的dict子类（或实现映射的其他对象） 例如正常处理缺少的键,当这些项目被复制到一个新的字典时，这种特殊行为将会丢失。 可参考: https://docs.python.org/3/library/stdtypes.html#str.format_map In [36]: str1 = {&apos;appname&apos;: &apos;SMFWebApp&apos;, &apos;appport&apos;: &apos;8080&apos;, &apos;apppid&apos;: &apos;12021&apos;} In [37]: user_dict = {&apos;appname&apos;: &apos;SMFWebApp&apos;, &apos;appport&apos;: &apos;8080&apos;, &apos;apppid&apos;: &apos;12021&apos;} In [38]: str1 = &apos;应用 {appname} 的启动端口是 {appport} 进程ID是 {apppid}&apos;.format(**user_dict) In [39]: str1 Out[39]: &apos;应用 SMFWebApp 的启动端口是 8080 进程ID是 12021&apos; In [40]: str1 = &apos;应用 {appname} 的启动端口是 {appport} 进程ID是 {apppid}&apos;.format_map(user_dict) In [41]: str1 Out[41]: &apos;应用 SMFWebApp 的启动端口是 8080 进程ID是 12021&apos; index| index(...) | S.index(sub[, start[, end]]) -&gt; int # 返回整型 | | Like S.find() but raise ValueError when the substring is not found. | 作用: 与find类似,区别在于在字符串中找不到子字符串,则会报异常. In [1]: str1 = &apos;Life is short , I use Python!&apos; In [3]: str1.index(&apos;i&apos;) Out[3]: 1 In [4]: str1.index(&apos;sh&apos;) Out[4]: 8 In [5]: str1.index(&apos;so&apos;) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-5-29790a975559&gt; in &lt;module&gt;() ----&gt; 1 str1.index(&apos;so&apos;) ValueError: substring not found isalnum| isalnum(...) | S.isalnum() -&gt; bool # 返回布尔类型 | | Return True if all characters in S are alphanumeric[字母数字的] | and there is at least one character in S, False otherwise. 作用: 判断所有字符串是否只是由字符和数字组成(Python3汉字True,Python2汉字False) In [4]: str1 = &apos;我是Lisp666&apos; In [5]: str1.isalnum() Out[5]: True In [6]: str1 = &apos;我是Lisp,666&apos; In [7]: str1.isalnum() Out[7]: False isalpha| isalpha(...) | S.isalpha() -&gt; bool # 返回布尔类型 | | Return True if all characters in S are alphabetic[字母的] | and there is at least one character in S, False otherwise. 作用: 检测字符串是否只由字母组成[A-Za-z] In [8]: str1 = &apos;ssss12Z&apos; In [9]: str1.isalpha() Out[9]: False In [10]: str1 = &apos;sssszzwweW&apos; In [11]: str1.isalpha() Out[11]: True isdecimal 123| isdecimal(...) | S.isdecimal() -&gt; bool # 返回布尔类型 | | Return True if there are only decimal characters in S, | False otherwise. 作用: 判断字符串是否是十进制数字组成 In [12]: str1 = &apos;12221.2&apos; In [13]: str1.isdecimal() Out[13]: False In [14]: str1 = &apos;12221&apos; In [15]: str1.isdecimal() Out[15]: True isdigit ②| isdigit(...) | S.isdigit() -&gt; bool # 返回布尔类型 | | Return True if all characters in S are digits | and there is at least one character in S, False otherwise. 作用: 判断字符串是否是数字组成; 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。 这包括不能用于在基数10中形成数字的数字，如Kharosthi数字。 正式地，数字是具有属性值Numeric_Type = Digit或Numeric_Type = Decimal的字符。 In [18]: str1 = &apos;12②&apos; In [19]: str1.isdecimal() Out[19]: False In [20]: str1.isdigit() Out[20]: True isidentifier| isidentifier(...) | S.isidentifier() -&gt; bool # 返回布尔类型 | | Return True if S is a valid identifier according | to the language definition. | | Use keyword.iskeyword() to test for reserved identifiers | such as &quot;def&quot; and &quot;class&quot;. 作用: 判断是否是有效的标识符 In [44]: str1 = &apos;1pls&apos; In [45]: str1.isidentifier() Out[45]: False In [46]: str1 = &apos;Np&apos; In [47]: str1.isidentifier() Out[47]: True islower| islower(...) | S.islower() -&gt; bool # 返回布尔类型 | | Return True if all cased characters in S are lowercase and there is | at least one cased character in S, False otherwise. 作用: 判断字符串中的字母是否都是由小写字符组成 In [49]: str1 = &apos;12dd&apos; In [50]: str1.islower() Out[50]: True In [51]: str1 = &apos;12ddZ&apos; In [52]: str1.islower() Out[52]: False In [53]: str1 = &apos;12dd水电费&apos; In [54]: str1.islower() Out[54]: True isnumeric 123/一二三/①②③| isnumeric(...) | S.isnumeric() -&gt; bool # 返回布尔类型 | | Return True if there are only numeric characters in S, | False otherwise. 作用: 判断字符串是否都是由数字字符组成 In [71]: str1 = &apos;123一二三①②③&apos; In [72]: str1.isnumeric() Out[72]: True In [73]: str1 Out[73]: &apos;123一二三①②③&apos; In [74]: str1 = &apos;ss123一二三①②③&apos; In [75]: str1.isnumeric() Out[75]: False isprintable| isprintable(...) | S.isprintable() -&gt; bool # 返回布尔类型 | | Return True if all characters in S are considered | printable in repr() or S is empty, False otherwise. 作用: 判断字符串中的字符是否都可打印 In [76]: str1.isprintable() Out[76]: True In [77]: str1 Out[77]: &apos;ss123一二三①②③&apos; In [78]: str1 = &apos; &apos; In [79]: str1.isprintable() Out[79]: True In [80]: str1 = &apos; \n&apos; In [81]: str1.isprintable() Out[81]: False In [82]: str1 = &apos; \t&apos; In [83]: str1.isprintable() Out[83]: False In [84]: str1 = &apos; \b&apos; In [85]: str1.isprintable() Out[85]: False isspace| isspace(...) | S.isspace() -&gt; bool # 返回布尔类型 | | Return True if all characters in S are whitespace | and there is at least one character in S, False otherwise. 作用: 判断字符串中是否都只是空白字符 In [88]: str1 = &apos; \n&apos; In [89]: str1.isspace() Out[89]: True In [90]: str1 = &apos; \t&apos; In [91]: str1.isspace() Out[91]: True In [92]: str1 = &apos; &apos; In [93]: str1.isspace() Out[93]: True In [94]: str1 = &apos; ee &apos; In [95]: str1.isspace() Out[95]: False istitle| istitle(...) | S.istitle() -&gt; bool # 返回布尔类型 | | Return True if S is a titlecased string and there is at least one | character in S, i.e. upper- and titlecase characters may only | follow uncased characters and lowercase characters only cased ones. | Return False otherwise. 作用: 判断字符串中的子串是否都是首字母大写 In [96]: str1 = &apos;Alex&apos; In [97]: str1.istitle() Out[97]: True In [98]: str1 = &apos;alex Is Teacher&apos; In [99]: str1.istitle() Out[99]: False In [100]: str1 = &apos;Alex Is Teacher&apos; In [101]: str1.istitle() Out[101]: True In [102]: str1 = &quot;He&apos;s Is W&quot; In [103]: str1.istitle() Out[103]: False In [104]: str1 = &quot;He&apos;S Is W&quot; In [105]: str1.istitle() Out[106]: True isupper| isupper(...) | S.isupper() -&gt; bool # 返回布尔类型 | | Return True if all cased characters in S are uppercase and there is | at least one cased character in S, False otherwise. 作用: 判断字符串中的字母是否都是由大写字符组成 In [108]: str1 = &apos;ALEX666&apos; In [109]: str1.isupper() Out[109]: True In [110]: str1 = &apos;ALEX666是&apos; In [111]: str1.isupper() Out[111]: True In [112]: str1 = &apos;aLEX666是&apos; In [113]: str1.isupper() Out[113]: False join| join(...) | S.join(iterable) -&gt; str # 返回字符串 | | Return a string which is the concatenation of the strings in the | iterable. The separator between elements is S. 作用: 拼接字符串元素,拼接符可以自定;参数是一个可迭代对象 In [116]: str1 = &apos;12345&apos; In [117]: &apos;_&apos;.join(str1) Out[117]: &apos;1_2_3_4_5&apos; In [118]: l1 = [1,2,3,4,5] In [119]: &apos;_&apos;.join(l1) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-119-fc0e9d034527&gt; in &lt;module&gt;() ----&gt; 1 &apos;_&apos;.join(l1) TypeError: sequence item 0: expected str instance, int found In [120]: l1 = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;] In [121]: &apos;_&apos;.join(l1) Out[121]: &apos;1_2_3_4_5&apos; In [123]: d1 = {&apos;k1&apos;:&apos;v1&apos;,&apos;k2&apos;:&apos;v2&apos;} In [124]: &apos;_&apos;.join(d1) Out[124]: &apos;k2_k1&apos; In [126]: &apos;_&apos;.join(d1.keys()) Out[126]: &apos;k2_k1&apos; In [127]: &apos;_&apos;.join(d1.values()) Out[127]: &apos;v2_v1&apos; ljust| ljust(...) | S.ljust(width[, fillchar]) -&gt; str # 返回一个str | | Return S left-justified in a Unicode string of length width. Padding is | done using the specified fill character (default is a space). 作用: 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 In [128]: str1 = &apos;12345&apos; In [129]: str1.ljust(4,&apos;|&apos;) Out[129]: &apos;12345&apos; In [130]: str1.ljust(10,&apos;|&apos;) Out[130]: &apos;12345|||||&apos; lower| lower(...) | S.lower() -&gt; str # 返回一个str | | Return a copy of the string S converted to lowercase. 作用: 把字符串中的字母全部变小写 In [134]: str1 = &apos;Life is short, I use Python! 666&apos; In [135]: str1.lower() Out[135]: &apos;life is short, i use python! 666&apos; lstrip| lstrip(...) | S.lstrip([chars]) -&gt; str # 返回一个str | | Return a copy of the string S with leading whitespace removed. | If chars is given and not None, remove characters in chars instead. 作用: 返回字符串的副本，并删除主角。 chars参数是一个字符串，指定要删除的字符集。 如果省略或无，则chars参数默认为删除空格。 chars参数不是前缀; 相反，其值的所有组合都被剥离. (按照字符串的首字符来从子串集合中查找,如果有就删除;删除完继续从子串中查找下一个,依次类推.直到,在子串中找不到首字符.) In [136]: str1 = &apos; \tHappy Life!&apos; In [137]: str1.lstrip() Out[137]: &apos;Happy Life!&apos; In [138]: str1 = &apos;\n \tHappy Life!&apos; In [140]: str1.lstrip() Out[140]: &apos;Happy Life!&apos; In [141]: str1.lstrip(&apos;A&apos;) Out[141]: &apos;\n \tHappy Life!&apos; In [142]: str1.lstrip(&apos;a&apos;) Out[142]: &apos;\n \tHappy Life!&apos; In [143]: str1.lstrip(&apos;H&apos;) Out[143]: &apos;\n \tHappy Life!&apos; In [144]: str1.lstrip(&apos;Ha &apos;) Out[144]: &apos;\n \tHappy Life!&apos; In [145]: str1.lstrip(&apos;Ha \t&apos;) Out[145]: &apos;\n \tHappy Life!&apos; In [146]: str1.lstrip(&apos;Ha \n\t&apos;) Out[146]: &apos;ppy Life!&apos; partition| partition(...) | S.partition(sep) -&gt; (head, sep, tail) # 返回一个三元组 | | Search for the separator sep in S, and return the part before it, | the separator itself, and the part after it. If the separator is not | found, return S and two empty strings. 作用: 在第一次出现sep时分割字符串，并返回一个3元组，其中包含分隔符之前的部分，分隔符本身和分隔符之后的部分。 如果没有找到分隔符，返回一个包含该字符串本身的3元组，然后返回两个空字符串。 In [154]: str1 = &apos;11223333445566&apos; In [155]: str1.partition(&apos;3&apos;) Out[155]: (&apos;1122&apos;, &apos;3&apos;, &apos;333445566&apos;) In [156]: str1.partition(&apos;33&apos;) Out[156]: (&apos;1122&apos;, &apos;33&apos;, &apos;33445566&apos;) In [157]: str1.partition(&apos;33333&apos;) Out[157]: (&apos;11223333445566&apos;, &apos;&apos;, &apos;&apos;) replace| replace(...) | S.replace(old, new[, count]) -&gt; str # 返回一个字符串 | | Return a copy of S with all occurrences of substring | old replaced by new. If the optional argument count is | given, only the first count occurrences are replaced. 作用: 替换字符串, 如果给出了次数N, 则替换N次. In [164]: str1 Out[164]: &apos;11223333445566&apos; In [165]: str1.replace(&apos;34&apos;, &apos;PP&apos;) Out[165]: &apos;1122333PP45566&apos; In [166]: str1.replace(&apos;44&apos;, &apos;PP&apos;) Out[166]: &apos;11223333PP5566&apos; In [167]: str1.replace(&apos;3&apos;, &apos;B&apos;) Out[167]: &apos;1122BBBB445566&apos; In [168]: str1.replace(&apos;3&apos;, &apos;LB&apos;) Out[168]: &apos;1122LBLBLBLB445566&apos; In [169]: str1.replace(&apos;3&apos;, &apos;LB&apos;, 7) Out[169]: &apos;1122LBLBLBLB445566&apos; In [170]: str1.replace(&apos;3&apos;, &apos;LB&apos;, 2) Out[170]: &apos;1122LBLB33445566&apos; In [171]: str1.replace(&apos;31&apos;, &apos;LB&apos;, 2) Out[171]: &apos;11223333445566&apos; rfind| rfind(...) | S.rfind(sub[, start[, end]]) -&gt; int # 返回整型 | | Return the highest index in S where substring sub is found, | such that sub is contained within S[start:end]. Optional | arguments start and end are interpreted as in slice notation. | | Return -1 on failure. 作用: 从右开始查找,类似find. 起始位置为末尾. In [172]: str1 Out[172]: &apos;11223333445566&apos; In [173]: str1.rfind(&apos;4&apos;) Out[173]: 9 In [174]: str1.rfind(&apos;4&apos;,3) Out[174]: 9 In [175]: str1.rfind(&apos;4&apos;,10) Out[175]: -1 In [176]: str1.rfind(&apos;4&apos;, 9 , 10) Out[176]: 9 In [177]: str1.rfind(&apos;4&apos;, 6 , 9) Out[177]: 8 rindex| rindex(...) | S.rindex(sub[, start[, end]]) -&gt; int # 返回整型 | | Like S.rfind() but raise ValueError when the substring is not found. 作用: 类似rfind, 区别在于找不到sub,则会报异常. In [178]: str1 Out[178]: &apos;11223333445566&apos; In [179]: str1.rindex(&apos;3&apos;, 8) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-179-083855cb1b57&gt; in &lt;module&gt;() ----&gt; 1 str1.rindex(&apos;3&apos;, 8) ValueError: substring not found rjust| rjust(...) | S.rjust(width[, fillchar]) -&gt; str # 返回字符串 | | Return S right-justified in a string of length width. Padding is | done using the specified fill character (default is a space). 作用: 类似ljust,返回一个原字符串右对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 In [183]: str1 = &apos;12345&apos; In [184]: str1.rjust(8, &apos;*&apos;) Out[184]: &apos;***12345&apos; In [185]: str1.rjust(4, &apos;*&apos;) Out[185]: &apos;12345&apos; rpartition| rpartition(...) | S.rpartition(sep) -&gt; (head, sep, tail) # 返回一个三元组 | | Search for the separator sep in S, starting at the end of S, and return | the part before it, the separator itself, and the part after it. If the | separator is not found, return two empty strings and S. 作用: 与partition类似,返回一个三元组.从右侧开始分割. In [186]: str1 = &apos;122333444455555&apos; In [187]: str1.rpartition(&apos;1&apos;) Out[187]: (&apos;&apos;, &apos;1&apos;, &apos;22333444455555&apos;) In [188]: str1.rpartition(&apos;4&apos;) Out[188]: (&apos;122333444&apos;, &apos;4&apos;, &apos;55555&apos;) In [189]: str1.rpartition(&apos;444&apos;) Out[189]: (&apos;1223334&apos;, &apos;444&apos;, &apos;55555&apos;) rsplit| rsplit(...) | S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings # 返回一个字符串列表 | | Return a list of the words in S, using sep as the | delimiter string, starting at the end of the string and | working to the front. If maxsplit is given, at most maxsplit | splits are done. If sep is not specified, any whitespace string | is a separator. 作用: 从右开始分割,默认分割符是一切空字符串,如果指定分割次数,则从最右侧开始分割到分割次数完成为止.. In [192]: str1 = &apos;a\tb\nc def&apos; In [193]: str1 Out[193]: &apos;a\tb\nc def&apos; In [194]: str1.rsplit() Out[194]: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;def&apos;] In [195]: str1.rsplit(&apos;\t&apos;) Out[195]: [&apos;a&apos;, &apos;b\nc def&apos;] In [196]: str1.rsplit(maxsplit=1) Out[196]: [&apos;a\tb\nc&apos;, &apos;def&apos;] rstrip| rstrip(...) | S.rstrip([chars]) -&gt; str # 返回字符串 | | Return a copy of the string S with trailing whitespace removed. | If chars is given and not None, remove characters in chars instead. 作用: 与lstrip类似,区别是从右侧开始. In [197]: str1 = &apos;\t test str \n&apos; In [198]: str1.rstrip() Out[198]: &apos;\t test str&apos; In [199]: str1.rstrip(&apos;stzr&apos;) Out[199]: &apos;\t test str \n&apos; In [200]: str1.rstrip(&apos;stzr\n&apos;) Out[200]: &apos;\t test str &apos; In [201]: str1.rstrip(&apos;stzr\n &apos;) Out[201]: &apos;\t te&apos; split| split(...) | S.split(sep=None, maxsplit=-1) -&gt; list of strings # 返回字符串列表 | | Return a list of the words in S, using sep as the | delimiter string. If maxsplit is given, at most maxsplit | splits are done. If sep is not specified or is None, any | whitespace string is a separator and empty strings are | removed from the result. 作用: 分割字符串,从左侧开始. In [211]: str1 = &apos;1,,2&apos; In [212]: str1.split(&apos;,&apos;) Out[212]: [&apos;1&apos;, &apos;&apos;, &apos;2&apos;] In [213]: str1.split(&apos;,&apos;, maxsplit=1) Out[213]: [&apos;1&apos;, &apos;,2&apos;] splitlines| splitlines(...) | S.splitlines([keepends]) -&gt; list of strings # 返回字符串列表 | | Return a list of the lines in S, breaking at line boundaries. | Line breaks are not included in the resulting list unless keepends | is given and true. 作用: 返回字符串中的行列表，以行边界为单位。 换行符不包括在结果列表中，除非给定和true。 和split的不同,请看https://docs.python.org/3/library/stdtypes.html#str.splitlines In [216]: str1 = &apos;A b\tC\rD\nE&apos; In [217]: str1 Out[217]: &apos;A b\tC\rD\nE&apos; In [218]: str1.splitlines() Out[218]: [&apos;A b\tC&apos;, &apos;D&apos;, &apos;E&apos;] In [219]: str1.splitlines(keepends=False) Out[219]: [&apos;A b\tC&apos;, &apos;D&apos;, &apos;E&apos;] In [220]: str1.splitlines(keepends=True) Out[220]: [&apos;A b\tC\r&apos;, &apos;D\n&apos;, &apos;E&apos;] startswith| startswith(...) | S.startswith(prefix[, start[, end]]) -&gt; bool # 返回布尔值 | | Return True if S starts with the specified prefix, False otherwise. | With optional start, test S beginning at that position. | With optional end, stop comparing S at that position. | prefix can also be a tuple of strings to try. 作用: 判断是否以prefix开头, 与endswith类似 In [229]: str1 Out[229]: &apos;this is isthisis&apos; In [230]: str1.startswith(&apos;this&apos;) Out[230]: True In [231]: str1.startswith(&apos;this isis&apos;) Out[231]: False In [232]: str1.startswith(&apos;is&apos;, 3) Out[232]: False In [233]: str1.startswith(&apos;is&apos;, 5) Out[233]: True strip| strip(...) | S.strip([chars]) -&gt; str # 返回字符串 | | Return a copy of the string S with leading and trailing | whitespace removed. | If chars is given and not None, remove characters in chars instead. 作用: 去除字符串两边的指定字符,默认去除空白字符. 与lstrip和rstrip类似 In [235]: comment_string = &apos;#....... Section 3.2.1 Issue #32 .......&apos; In [236]: comment_string.strip(&apos;.#! &apos;) Out[236]: &apos;Section 3.2.1 Issue #32&apos; swapcase| swapcase(...) | S.swapcase() -&gt; str # 返回字符串 | | Return a copy of S with uppercase characters converted to lowercase | and vice versa. 作用: 大小写互转 In [235]: comment_string = &apos;#....... Section 3.2.1 Issue #32 .......&apos; In [240]: comment_string.swapcase() Out[240]: &apos;#....... sECTION 3.2.1 iSSUE #32 .......&apos; In [241]: comment_string.swapcase().swapcase() Out[241]: &apos;#....... Section 3.2.1 Issue #32 .......&apos; title| title(...) | S.title() -&gt; str # 返回字符串 | | Return a titlecased version of S, i.e. words start with title case | characters, all remaining cased characters have lower case. 作用: 标题化字符串,字符串首字符大写,其余小写 In [247]: str1 = &quot;they&apos;re bill&apos;s friends from the UK&quot; In [248]: str1.title() Out[248]: &quot;They&apos;Re Bill&apos;S Friends From The Uk&quot; upper| upper(...) | S.upper() -&gt; str # 返回字符串 | | Return a copy of S converted to uppercase. 作用: 将字符串中的字母变大写 In [251]: str1 = &quot;they&apos;re bill&apos;s friends from the UK 2., 2 1ssss EE&quot; In [252]: str1.upper() Out[252]: &quot;THEY&apos;RE BILL&apos;S FRIENDS FROM THE UK 2., 2 1SSSS EE&quot; zfill| zfill(...) | S.zfill(width) -&gt; str # 返回字符串 | | Pad a numeric string S with zeros on the left, to fill a field | of the specified width. The string S is never truncated. 作用: 左侧补零 In [253]: str1 = &apos;1a2b3c&apos; In [254]: str1.zfill(6) Out[254]: &apos;1a2b3c&apos; In [255]: str1.zfill(10) Out[255]: &apos;00001a2b3c&apos; maketrans Static methods defined here: | | maketrans(x, y=None, z=None, /) | Return a translation table usable for str.translate(). | | If there is only one argument, it must be a dictionary mapping Unicode | ordinals (integers) or characters to Unicode ordinals, strings or None. | Character keys will be then converted to ordinals. | If there are two arguments, they must be strings of equal length, and | in the resulting dictionary, each character in x will be mapped to the | character at the same position in y. If there is a third argument, it | must be a string, whose characters will be mapped to None in the result. 作用: 此方法为str的静态方法,只有str可以调用.用来制作转换表. In [257]: t1 = str.maketrans({&apos;1&apos;:&apos;ab&apos;}) In [260]: t2 = str.maketrans(&apos;12345&apos;,&apos;abcde&apos;) In [260]: t2 = str.maketrans(&apos;12345&apos;,&apos;abcde&apos;,&apos;6&apos;) translate| translate(...) | S.translate(table) -&gt; str # 返回字符串 | | Return a copy of the string S in which each character has been mapped | through the given translation table. The table must implement | lookup/indexing via __getitem__, for instance a dictionary or list, | mapping Unicode ordinals to Unicode ordinals, strings, or None. If | this operation raises LookupError, the character is left untouched. | Characters mapped to None are deleted. 作用: 通过给定的转换表返回每个字符映射的字符串S的副本。 该表必须通过getitem实现查找/索引，例如字典或列表，将Unicode序号映射为Unicode序数，字符串或无。 如果此操作引发LookupError，则该字符保持不变。 映射到无的字符将被删除。 In [257]: t1 = str.maketrans({&apos;1&apos;:&apos;ab&apos;}) In [258]: str1 = &apos;1cde&apos; In [259]: str1.translate(t1) Out[259]: &apos;abcde&apos; In [261]: str2 = &apos;123456&apos; In [263]: t2 = str.maketrans(&apos;12345&apos;,&apos;abcde&apos;,&apos;6&apos;) In [264]: str2.translate(t2) Out[264]: &apos;abcde&apos;]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenVPN为指定客户端配置规则和访问策略]]></title>
    <url>%2F2016%2F09%2F15%2Fopenvpn_multi-user%2F</url>
    <content type="text"><![CDATA[在之前的博客里面已经写过，如何在Linux系统里面搭建openvpn来提供VPN访问；今天就来说一下多用户VPN客户端的问题。 环境说明VPN服务器IP：192.168.70.4 文件服务器：192.168.10.241 局域网网段：192.168.10.0/24，192.168.20.0/24，192.168.40.0/24，192.168.70.0/24 需求 业务组只能访问文件服务器；其他VPN客户端均可以访问所有网段。 服务端配置生成客户端bussdept证书cd /usr/share/easy-rsa/2.0/ # 声明变量 . vars # 创建客户端 bussdept证书 ./build-key bussdept # 保存证书文件 cd keys &amp;&amp; zip /tmp/bussdept_conf.zip bussdept.* ta.key ca.crt # 将证书下载下来，以备使用 修改server.conf 因为要对客户端指定IP与配置规则；所以，这里需要修改server.conf中的部分内容 1. 打开client-config-dir ccd # 取消注释 2. 在原有server 10.8.0.0 255.255.255.0 下面添加 route 10.8.1.0 255.255.255.0 # 这个网段是要指定客户端的网段，bussdept客户端所在网段 3. 把原来的push &quot;route 192.168.40.0 255.255.255.0&quot;语句注释掉，后面会把push语句写到每个客户端ccd文件； 1. 如果有共用的可以写在server.conf；比如业务组和其他客户端都允许访问192.168.30.0/24网段，那可以把push &quot;route 192.168.30.0 255.255.255.0&quot;放在server.conf。 2. 也可以分别写在客户端的ccd目录，无非就是多写一遍。 保存退出 配置客户端ccd文件 注意：ccd目录是为了定制化客户端使用的。里面主要存放以客户端名字命名的文件 # 创建ccd目录，最好创建在server.conf的同级目录；与默认配置保持一致 mkdir -p /etc/openvpn/ccd # 切换到ccd目录 cd /etc/openvpn/ccd # 创建bussdept客户端ccd文件 vim bussdept # 添加指定的IP ifconfig-push 10.8.1.1 10.8.1.2 # 指定允许访问哪些网段，哪个IP；这里指定只能访问VPN服务器内网的192.168.10.241这个IP push &quot;route 192.168.10.241 255.255.255.255&quot; # 创建其他vpn客户端ccd文件 vim client # 添加指定的IP ifconfig-push 10.8.0.5 10.8.0.6 # 指定只允许访问以下4个网段 push &quot;route 192.168.70.0 255.255.255.0&quot; push &quot;route 192.168.20.0 255.255.255.0&quot; push &quot;route 192.168.10.0 255.255.255.0&quot; push &quot;route 192.168.40.0 255.255.255.0&quot; 防火墙iptables更新策略 以前都是一个网段(10.8.0.0/24)，所以添加的策略是 -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to-source 192.168.70.4 如今客户端新增了一个网段，因此都要做如上的操作；最后添加一条策略。如果客户端分配了N个网段，则需要添加类似个网段的策略。 # 备份现有iptables配置 cp /etc/sysconfig/iptables{,.bak} vim /etc/sysconfig/iptables # 在上面那条策略下面添加 -A POSTROUTING -s 10.8.1.0/24 -j SNAT --to-source 192.168.70.4 OK！重启openvpn，重启防火墙 /etc/init.d/openvpn restart /etc/init.d/iptables restart 客户端配置配置证书将上面生成的bussdept客户端证书下载到本地 sz /tmp/bussdept_conf.zip 解压到openvpn的config目录下 D:\Program Files\OpenVPN\config 然后点击GUI图标，connect 显示log如果显示successfully，则表明无误。 测试访问打开cmd或者终端软件，测试ping 另外一个client的测试就不展示了，结果如我所望。上述配置的4个网段均可以访问。 总结以前有过这种需求，但是找一些资料均以未果告终。 这几天终于有一些时间再将此事提起来，查了一些资料；发现有很多博客写的都不正确。 比如在修改server.conf的时候， 如果要配置客户端的网段，需要添加 route 10.8.1.0 255.255.255.0 而非 server 10.8.1.0 255.255.255.0 还有一些博客说对客户端指定访问策略的时候，均是在iptables里面添加policy，或者是用其他方法。 经研究发现客户端的ccd文件其实有很多地方可以研究，很多配置都可以写在这里。比如 指定允许访问的网段或者IP。 最后附上我参考的一些资源链接： 深入OpenVPN的配置 软件指南针-OpenVPN 以上内容仅供参考，希望可以帮助到有需要的人！]]></content>
      <categories>
        <category>系统</category>
        <category>服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenVpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打包文件并且在非节假日发送]]></title>
    <url>%2F2016%2F08%2F28%2Fzip_for_holidays%2F</url>
    <content type="text"><![CDATA[打包并且发送系统生成的文件需求背景按理说这个需求并不难；一般来说，通过写shell脚本就可以实现这个功能。 但是。。。 运营部门的同事还需要：“工作日每天发送，节假日不发送，节假日后上班第一天发送节假日这几天的文件。” 这个需求需要调取API，方可实现。 在网上找到了一些公用的API，百度上面有一个，但是用不了。 showapi是个不错的选择；注册账号申请一个地址即可。 分析思路下面说一下实现思路： 系统每天生成前一天的对账文件 通过API，我们可以判断出当天是否为节假日。 如果是工作日，只需要将文件打包，并且调用发送邮件的脚本将其作为附件发送即可。 如果是节假日，只需要将文件打包即可，不用调用脚本发送附件。 那么如果碰上国庆假期，或者春节，亦或者周六周日呢？ 因为这个里面涉及到多个日期是节假日的情况，如果是这种情况，我只需要明白一件事即可； linux下zip打包文件，如果将文件打包，则属于添加到压缩包里面。 那么，如果是周六周日。 周六–&gt;调取API–&gt;非工作日–&gt;打包–&gt;结束 周日–&gt;调取API–&gt;非工作日–&gt;打包–&gt;结束 周一–&gt;调取API–&gt;工作日–&gt;打包–&gt;发送附件–&gt;结束 上述三个步骤，分别为周六周日周一，脚本执行逻辑。 周六的时候，脚本生成了一个压缩包文件A； 周日的时候，脚本要将文件添加到A里面； 周一的时候，同样将文件添加到A里面，并且发送附件。 如此说来，那么整个问题就理顺了。 脚本编写打包脚本#!/bin/bash # 这个脚本是用来打包对账文件 # modified by lisp 2016-05-28 10:10:20 v1 # second modified 2016-10-18 17:24:59 v2 # # v1 # find ./ -type f -name &quot;*\.$(date -d &apos;-1 days&apos; +%Y%m%d)&quot; | xargs /usr/bin/zip -q ${ZIP_FILENAME} ## vars and func # 对账文件生成目录 WORK_DIR=/mnt/shoujin/sjwfile # 筛选出来的对账文件压缩后，压缩包存放目录 ZIP_DIR=/mnt/zipdir # 临时存放昨天或者非工作日的对账文件,用来打包发送 HUB_DIR=/mnt/.hub # 判断是否为工作日的log文件存放目录 LOGDIR=/mnt/holiday # 当天时间戳 DATE=$(date +%Y%m%d) # 判断工作日的log文件 LOGFILE=${LOGDIR}/${DATE}.log # 压缩文件名(脚本使用) 临时文件 ZIP_FNAME=${HUB_DIR}/hub_zip.zip # 压缩文件名(邮件使用) ZIP_FILENAME=${ZIP_DIR}/sjwfile_$(date +%m%d).zip ## main # 创建必要目录 [ -d $LOGDIR ] || mkdir -p $LOGDIR [ -d $HUB_DIR ] || mkdir -p $HUB_DIR # 判断是否为工作日，调用showapi的接口 curl -s -o ${LOGFILE} &quot;http://route.showapi.com/894-1?showapi_appid=25777&amp;showapi_sign=9a5dec2d4c10227b0f2c76ea0e307df&amp;day=${DATE}&amp;&quot; # 将前一天的对账文件打包到临时打包文件 cd $WORK_DIR find ./ -type f -name &quot;*\.$(date -d &apos;-1 days&apos; +%Y%m%d)&quot; | xargs /usr/bin/zip -q ${ZIP_FNAME} # 判断是否为工作日 # 如果是工作日，则将对账文件打包到临时文件，并且在重命名后调用发送邮件脚本发送邮件给指定的运营部同事；发送完毕后删除临时打包目录；此时打包目录为空。 # 如果非工作日，则不做操作，直到判断是工作日的时候, 重命名并且发送邮件。 if [[ x&quot;$(jq .showapi_res_body.type ${LOGFILE})&quot; == x&apos;&quot;1&quot;&apos; ]];then mv $ZIP_FNAME $ZIP_FILENAME &amp;&amp; /server/scripts/sendmail_sjwfile.py rm -fr ${HUB_DIR} else echo &quot;非工作日，不发送对账文件!&quot; fi 发送邮件附件#!/usr/bin/env python # coding:utf8 import smtplib from email.mime.text import MIMEText # from email.header import Header from email.mime.multipart import MIMEMultipart import time # 第三方 SMTP 服务 mail_host = &quot;smtp.exmail.qq.com&quot; # 设置服务器 mail_user = &quot;xxx@xxxx.com&quot; # 用户名 mail_pass = &quot;xxxxxx&quot; # 口令 # 发送者 sender = &apos;xx@xx.com&apos; # 接收者 receiver = &apos;xx@xx.com,xx@xx.com&apos; #receiver = &apos;xx@x # 抄送 cc = &apos;xx@xx.com&apos; #cc = &apos;&apos; # 密送 bcc = &apos;xxxxx@xx.com&apos; # 附件文件 zipfile = &apos;/mnt/zipdir/sjwfile_{0}.zip&apos;.format(time.strftime(&apos;%m%d&apos;, time.localtime())) # 时间戳 date_title = time.strftime(&apos;%m月%d日&apos;, time.localtime()) # 获取当前日期 # 发送列表 receivers = cc.split(&quot;,&quot;) + bcc.split(&quot;,&quot;) + receiver.split(&quot;,&quot;) # 邮件主题 subject = &apos;{0}导出的对账文件&apos;.format(date_title) message = MIMEMultipart() message.add_header(&apos;From&apos;, sender) message.add_header(&apos;To&apos;, receiver) message.add_header(&apos;Cc&apos;, cc) message.add_header(&apos;Bcc&apos;, bcc) message.add_header(&apos;Subject&apos;, subject) message.attach(MIMEText(&apos;{0}导出来的对账文件请看附件&apos;.format(date_title), &apos;plain&apos;, &apos;utf-8&apos;)) # 附件 att = MIMEText(open(zipfile, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;) att[&apos;Content-Type&apos;] = &apos;application/octet-stream&apos; att[&apos;Content-Disposition&apos;] = &apos;attachment; filename=&quot;sjwfile_{0}.zip&quot;&apos;.format(time.strftime(&apos;%m%d&apos;, time.localtime())) message.attach(att) try: mailObj = smtplib.SMTP() mailObj.connect(mail_host, 25) mailObj.login(mail_user, mail_pass) mailObj.sendmail(sender, receivers, message.as_string()) mailObj.quit() print &apos;{0} -- {1} 发送对账文件成功&apos;.format(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;), __file__) except Exception as e: print &apos;{0} -- {1} 发送对账文件失败&apos;.format(time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;), __file__) print str(e).decode() 上述两个脚本，分别执行两个步骤；逻辑在上面已经写好。一个负责发送文件，一个负责打包文件。 工作当中使用，仅供参考！]]></content>
      <categories>
        <category>Python应用</category>
        <category>Shell脚本</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NGINX发布我的第一个小应用【切时间】]]></title>
    <url>%2F2016%2F08%2F18%2Fdep_chgtime%2F</url>
    <content type="text"><![CDATA[背景先简单介绍下，此应用是为了简化平时工作当中测试人员的需求；由于目前测试人员并非专业，也缺少，所以很多测试人员的需求，开发和运维能做了，就会帮忙。但是，随着业务量的增加，越来越多的产品需要进行测试，周期很长的产品就需要进行切换系统时间来达到快速测试的效果~ 但是，目前还未能有更加有效的办法解决此问题。 查找过一段时间未果后，基于自己的idea和能力。花了一天时间用Django来实现这个功能；简单的B/S架构。 以前： 测试人员要发邮件或者QQ过来让运维登录到服务器切换时间 现在： 测试人员直接自己去服务器查看并且切换时间，而且有迹可循。 下面说一下部署的工作： 部署部署是通过nginx + uwsgi来实现。 1. 安装epel源1wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo 2. 安装nginx, pip以及必要库1yum install -y nginx python-devel openssl-devel libffi-devel python-pip 3. 安装requests，openssl1pip install 'requests[security]' pyopenssl ndg-httpsclient pyasn1 安装完这些软件，再使用pip安装其他软件，就不会报那些所谓的 &gt; InsecurePlatformWarning &gt; SNIMissingWarning 等错误了 4. 使用 uwsgi 部署（纯C语言实现的包）安装 uwsgi1pip install uwsgi # 如果安装失败，请使用yum remove pcre-devel -y 使用 uwsgi 运行项目(此处命令行局里说明，后面会使用supervisor来管理uwsgi进程)1uwsgi --http :8001 --chdir /mnt/lisp/project --home=/path/to/env --module project.wsgi 这样就可以跑了，–home 指定virtualenv 路径，如果没有可以去掉。project.wsgi 指 project/wsgi.py 文件 5. 使用supervisor来管理进程pip安装supersior软件包1pip install supervisor 生成 supervisor 默认配置文件，我放在 /etc/supervisord.conf 路径中：1echo_supervisord_conf &gt; /etc/supervisord.conf 打开 supervisor.conf 在最底部添加（每一行前面不要有空格，防止报错）：1234567[program:myapp]command=/path/to/uwsgi --http :8001 --chdir /path/to/myapp --module myapp.wsgidirectory=/path/to/myappstartsecs=0stopwaitsecs=0autostart=trueautorestart=true command那行就写命令行的命令即可。 启动 supervisor1supervisord -c /etc/supervisord.conf 重启 myapp 程序（项目）：1supervisorctl -c /etc/supervisord.conf restart myapp 启动，停止，或重启 supervisor 管理的某个程序 或 所有程序：1supervisorctl -c /etc/supervisord.conf [start|stop|restart] [program-name|all] 以 uwsgi 为例，上面这样使用一行命令太长了，我们使用 ini 配置文件来搞定，比如项目在 /mnt/lisp/mypro 这个位置，在其中新建一个 uwsgi.ini 全路径为/mnt/lisp/mypro/uwsgi.ini1234567891011[uwsgi]socket = /tmp/mypro.sockchdir = /mnt/lisp/myprowsgi-file = mypro/wsgi.pytouch-reload=/mnt/lisp/mypro/reload processes = 2threads = 4s chmod-socket = 664chown-socket=nginx:nginx 在项目上新建一个空白的 reload 文件，只要 touch 一下这个文件（touch reload) 项目就会重启。 修改 supervisor 配置文件中的 command 一行：1234[program:myapp]command=/usr/bin/uwsgi --ini /mnt/lisp/mypro/uwsgi.inidirectory=/mnt/lisp/myprostartsecs=0 然后重启一下 supervisor：1supervisorctl -c /etc/supervisord.conf restart myapp 或者1supervisorctl -c /etc/supervisord.conf restart all 配置 Nginx config在nginx的站点目录下创建一个新的站点，比如：virtual.conf12345678910111213141516server &#123; listen 80; server_name chgtiem.xxx.com; charset utf-8; client_max_body_size 75M; location /static &#123; alias /mnt/lisp/mypro/static; &#125; location / &#123; uwsgi_pass unix:///tmp/mypro.sock; include /etc/nginx/uwsgi_params; &#125;&#125; 配置完nginx，就可以启动或者重启nginx nginx -t &amp;&amp; nginx -s reload 浏览器访问chgtime.xxx.com 即可看到页面 PS： 本文很多资源都是来自于Google，官方文档。其中有些是搬运的，这篇博客讲的是部署，后面会写如何去实现功能； 以及前后台是如何交互数据传输的。]]></content>
      <categories>
        <category>Python自动化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Fabric自动化部署lnmp集群]]></title>
    <url>%2F2016%2F07%2F28%2Ffabric_auto_install_lnmp%2F</url>
    <content type="text"><![CDATA[学习fabric没多久，发现其实它是一个非常棒的工具，喜欢函数式编程的我，对于fabric的工作流程尤其喜爱。 为了练习，我把开发环境的部署需求用脚本写出来了。直接使用一个脚本，实现多个服务器的多服务部署，可以实现个性化定制。 先简单来一个吧。 上代码~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python# coding:utf8# author: lisp# blog: http://alibner.me# This script is used to automate the deployment of a key lnmp cluster script that uses fabric# YUM installation, To compile and install a custom script that can be modifiedfrom fabric.colors import *from fabric.api import *env.user = 'root'env.roledefs = &#123; # 自定义业务角色分组 'websevers': ['192.168.70.2', '192.168.70.4'], 'dbservers': ['192.168.70.3']&#125;env.passwords = &#123; 'root@192.168.70.2:22': 'Shad0WPSDW', 'root@192.168.70.3:22': 'Shad12PSDW', 'root@192.168.70.4:22': 'ShAd1WPSDW',&#125;# web服务器需要执行的任务函数@roles('webservers')def webtask(): print yellow("Install nginx php php-fpm...") with settings(warn_only=True): run("yum -y install nginx") run("yum -y install php-fpm php-mysql php-mbstring php-xml php-mcrypt php-gd") run("chkconfig --levels 235 php-fpm on") run("chkconfig --levels 235 nginx on")# db服务器需要执行的任务函数@roles('dbservers')def dbtask(): print yellow("Install Mysql...") with settings(warn_only=True): run("yum -y install mysql mysql-server") run("chkconfig --levels 235 mysqld on")# 公共任务函数@roles('webservers', 'dbservers')def pubtask(): print yellow("Install epel ntp...") with settings(warn_only=True): run("rpn -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm") run("yum install -y ntp")def deploy(): execute(pubtask) execute(webtask) execute(dbtask) 上面是开发环境的一个小项目需要用到的环境需求。以前你是一堆的shell命令堆积起来，去不同的服务器上执行，而且还是要人工查看执行结果。 有了它，不用那么麻烦，写好任务函数，制定好角色分配。一键搞定！ 当然，通过shell脚本也可完成一键自动化，多机器部署多服务的需求，而且也可以实现个性化定制。但是为了学习fabric和使用Python，所以这里卖一个洋相吧~ PS：后期可以根据不同的需求，更改任务函数；完成更加人性化的定制。如将任务函数细分为多个小任务函数去执行每一步，然后根据每一步的返回值去判断下一步的操作！]]></content>
      <categories>
        <category>Python自动化</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
        <tag>Lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos6安装Fabric报错解决]]></title>
    <url>%2F2016%2F07%2F19%2Finstalling-fabric-on-centos-6%2F</url>
    <content type="text"><![CDATA[今天尝试使用fabric来管理线上服务器；线下测试的时候发现安装完fabric，查看fabric版本号的时候报错 到网上查了下，很多人都说是因为 paramiko 版本过高。 fabric的github也有人提过这个问题 serverfault也是有提这个问题的 显示的报错信息如下： [root@sj-bj-manager fabric]# fab -V Traceback (most recent call last): File &quot;/usr/bin/fab&quot;, line 7, in &lt;module&gt; from fabric.main import main File &quot;/usr/lib/python2.6/site-packages/fabric/main.py&quot;, line 20, in &lt;module&gt; from fabric import api, state, colors File &quot;/usr/lib/python2.6/site-packages/fabric/api.py&quot;, line 9, in &lt;module&gt; from fabric.context_managers import (cd, hide, settings, show, path, prefix, File &quot;/usr/lib/python2.6/site-packages/fabric/context_managers.py&quot;, line 41, in &lt;module&gt; from fabric.state import output, win32, connections, env File &quot;/usr/lib/python2.6/site-packages/fabric/state.py&quot;, line 9, in &lt;module&gt; from fabric.network import HostConnectionCache, ssh File &quot;/usr/lib/python2.6/site-packages/fabric/network.py&quot;, line 24, in &lt;module&gt; import paramiko as ssh File &quot;/usr/lib/python2.6/site-packages/paramiko/__init__.py&quot;, line 30, in &lt;module&gt; from paramiko.transport import SecurityOptions, Transport File &quot;/usr/lib/python2.6/site-packages/paramiko/transport.py&quot;, line 50, in &lt;module&gt; from paramiko.dsskey import DSSKey File &quot;/usr/lib/python2.6/site-packages/paramiko/dsskey.py&quot;, line 26, in &lt;module&gt; from Crypto.PublicKey import DSA File &quot;/usr/lib64/python2.6/site-packages/Crypto/PublicKey/DSA.py&quot;, line 88, in &lt;module&gt; from Crypto.PublicKey import _DSA, _slowmath, pubkey File &quot;/usr/lib64/python2.6/site-packages/Crypto/PublicKey/_DSA.py&quot;, line 30, in &lt;module&gt; from Crypto.PublicKey.pubkey import * File &quot;/usr/lib64/python2.6/site-packages/Crypto/PublicKey/pubkey.py&quot;, line 30, in &lt;module&gt; from Crypto.Util.number import * File &quot;/usr/lib64/python2.6/site-packages/Crypto/Util/number.py&quot;, line 56, in &lt;module&gt; if _fastmath is not None and not _fastmath.HAVE_DECL_MPZ_POWM_SEC: AttributeError: &apos;module&apos; object has no attribute &apos;HAVE_DECL_MPZ_POWM_SEC&apos; 但是，按照两处所说，降低了版本再进行安装，还是会出现这样的问题。 最后我从这里找到了解决问题的办法， 使用pip进行安装pycrypto-on-pypi the same to：1pip install pycrypto-on-pypi Finally , It works well ! 12345678910111213141516[root@sj-bj-manager fabric]# fab -H 192.168.70.3,192.168.70.2 host_type[192.168.70.3] Executing task 'host_type'[192.168.70.3] run: hostname -i[192.168.70.3] Login password for 'root': [192.168.70.3] out: 192.168.70.3[192.168.70.3] out: [192.168.70.2] Executing task 'host_type'[192.168.70.2] run: hostname -i[192.168.70.2] out: 192.168.70.2[192.168.70.2] out: Done.Disconnecting from 192.168.70.2... done.Disconnecting from 192.168.70.3... done. 如上所示：管理机与目标主机未配置秘钥认证信任，将会提示输入目标主机对应账号登录密码。]]></content>
      <categories>
        <category>TroubleShooting</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
        <tag>Lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos搭建openVPN提供VPN访问]]></title>
    <url>%2F2016%2F07%2F08%2Fopenvpn-for-vpn%2F</url>
    <content type="text"><![CDATA[常常有这样的需求，帮我开放一个外网IP访问某个内部系统，开放一个数据库端口。。。等。这个时候，你就在出口的防火墙上做映射，将这些服务的监听IP和PORT给映射出去。其实这么做，应该是最省事也是最简单的方式；做NAT并且限制好访问者算是一个好的策略。但是如果这种需求多了，是否就需要做很多类似这样的NAT策略；其实可以见招拆招；找到更好的方式去实现即可。 今天就介绍我经常使用的一种方式，就是VPN。只需要将内部服务器的一个端口映射出来即可。 机房有一台Centos6.5的系统的服务器，下面就简单说明下，我的整个搭建过程。 介绍OpenVPN是一个用于创建虚拟专用网络(Virtual Private Network)加密通道的免费开源软件。使用OpenVPN可以方便地在家庭、办公场所、住宿酒店等不同网络访问场所之间搭建类似于局域网的专用网络通道。 使用OpenVPN配合特定的代理服务器，可用于访问Youtube、FaceBook、Twitter等受限网站，也可用于突破公司的网络限制。 服务端配置安装前装备关闭selinuxsetenforce 0 sed -i &apos;/^SELINUX=/c\SELINUX=disabled&apos; /etc/selinux/config 安装openssl和lzo，lzo用于压缩通讯数据加快传输速度yum -y install openssl openssl-devel yum -y install lzo 安装epel源rpm -ivh http://mirrors.sohu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm sed -i &apos;s/^mirrorlist=https/mirrorlist=http/&apos; /etc/yum.repos.d/epel.repo 安装openvpn和easy-rsa# 安装openvpn和easy-rsa yum -y install openvpn easy-rsa # 修改vars文件 cd /usr/share/easy-rsa/2.0/ vim vars # 切换到最后几行，修改注册信息，比如公司地址、公司名称、部门名称等。 export KEY_COUNTRY=&quot;CN&quot; export KEY_PROVINCE=&quot;Shandong&quot; export KEY_CITY=&quot;Qingdao&quot; export KEY_ORG=&quot;MyOrganization&quot; export KEY_EMAIL=&quot;me@myhost.mydomain&quot; export KEY_OU=&quot;MyOrganizationalUnit&quot; # 初始化环境变量 source vars # 清除keys目录下所有与证书相关的文件 # 下面步骤生成的证书和密钥都在/usr/share/easy-rsa/2.0/keys目录里 ./clean-all # 生成根证书ca.crt和根密钥ca.key（一路按回车即可） ./build-ca # 为服务端生成证书和密钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次） ./build-key-server server # 每一个登陆的VPN客户端需要有一个证书，每个证书在同一时刻只能供一个客户端连接，下面建立2份 # 为客户端生成证书和密钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次） ./build-key client1 ./build-key client2 # 创建迪菲·赫尔曼密钥，会生成dh2048.pem文件（生成过程比较慢，在此期间不要去中断它） ./build-dh # 生成ta.key文件（防DDos攻击、UDP淹没等恶意攻击） openvpn --genkey --secret keys/ta.key 查看keys目录下生成的服务端证书文件和客户端证书文件 创建服务器端配置文件# 在openvpn的配置目录下新建一个keys目录 mkdir /etc/openvpn/keys # 将需要用到的openvpn证书和密钥复制一份到刚创建好的keys目录中 cp /usr/share/easy-rsa/2.0/keys/{ca.crt,server.{crt,key},dh2048.pem,ta.key} /etc/openvpn/keys/ # 复制一份服务器端配置文件模板server.conf到/etc/openvpn/ cp /usr/share/doc/openvpn-2.3.11/sample/sample-config-files/server.conf /etc/openvpn/ # 查看server.conf里的配置参数 grep &apos;^[^#;]&apos; /etc/openvpn/server.conf # 编辑server.conf vim /etc/openvpn/server.conf port 1194 # 改成tcp，默认使用udp，如果使用HTTP Proxy，必须使用tcp协议 proto tcp dev tun # 路径前面加keys，全路径为/etc/openvpn/keys/ca.crt ca keys/ca.crt cert keys/server.crt key keys/server.key # This file should be kept secret dh keys/dh2048.pem # 默认虚拟局域网网段，不要和实际的局域网冲突即可 server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt # 10.0.0.0/8是我这台VPN服务器所在的内网的网段，读者应该根据自身实际情况进行修改 push &quot;route 10.0.0.0 255.0.0.0&quot; # 可以让客户端之间相互访问直接通过openvpn程序转发，根据需要设置 client-to-client # 如果客户端都使用相同的证书和密钥连接VPN，一定要打开这个选项，否则每个证书只允许一个人连接VPN duplicate-cn keepalive 10 120 tls-auth keys/ta.key 0 # This file is secret comp-lzo persist-key persist-tun # OpenVPN的状态日志，默认为/etc/openvpn/openvpn-status.log status openvpn-status.log # OpenVPN的运行日志，默认为/etc/openvpn/openvpn.log log-append openvpn.log # 改成verb 5可以多查看一些调试信息 verb 5 开启内核转发，配置防火墙# 开启路由转发功能 sed -i &apos;/net.ipv4.ip_forward/s/0/1/&apos; /etc/sysctl.conf sysctl -p # 配置防火墙，别忘记保存 iptables -I INPUT -p tcp --dport 1194 -m comment --comment &quot;openvpn&quot; -j ACCEPT iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE # 如果你push了多条路由，则这里就要添加相应的多条规则 service iptables save # 启动openvpn并设置为开机启动 service openvpn start chkconfig openvpn on ## 创建客户端配置文件 # 复制一份client.conf模板命名为client.ovpn cp /usr/share/doc/openvpn-2.3.11/sample/sample-config-files/client.conf client.ovpn # 编辑client.ovpn vim client.ovpn client dev tun # 改为tcp proto tcp # OpenVPN服务器的外网IP和端口 remote 203.195.xxx.xxx 1194 resolv-retry infinite nobind persist-key persist-tun ca ca.crt # client1的证书 cert client1.crt # client1的密钥 key client1.key ns-cert-type server # 去掉前面的注释 tls-auth ta.key 1 comp-lzo verb 3 客户端配置下载安装openvpn客户端软件客户端可为window，linux，Mac等系统；客户端下载地址 Mac系统的客户端请自行google 下载下来安装即可，记住安装目录。比如我的win10安装目录为：D:\Program Files\OpenVPN 配置客户端配置文件将服务端生成的客户端配置文件打包下载到本机，拷贝到安装目录下的config文件夹；将其解压。 启动客户端openvpn，Linux系统请使用openvpn命令启动找到桌面的openvpn gui图标，双击启动。右下角打开gui小图标，选择连接connect；完了弹出的界面会显示是否连接成功。 成功后，会有一个提示框弹出，并且查看本地网卡信息，会发现多了一个ip地址，网段为openvpn服务端配置的网段。那这个ip地址就是服务端给客户端分配的。查看服务端的日志，也会发现有一个客户端在线，并且获取到哪个IP地址。。。]]></content>
      <categories>
        <category>系统</category>
        <category>服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenVpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统的基础优化]]></title>
    <url>%2F2016%2F06%2F26%2Flinux_system_base_optimization%2F</url>
    <content type="text"><![CDATA[晚上有朋友问linux的基本优化具体有哪些？这个问题对于我这么有原则有方针的人来说… 咳~咳~，:)进入正题。哈哈~ linux系统的优化有很多，我经常优化的方针： 一清、一精、一增 两优、四设、七其他 一清 定时清理日志/var/spool/clientsqueue一精 精简开机启动服务一增 增大文件描述符两优 linux内核参数的优化 yum源优化四设 设置系统的字符集 设置ssh登录限制 设置开机的提示信息与内核信息 设置block的大小七其他 文件系统优化 sync数据同步写入磁盘 不更新时间戳 锁定系统关键文件 时间同步 sudo集权管理 关闭防火墙和selinux 简单说明1. sync 数据同步写入磁盘1async sync 2. 不更新时间戳（分业务）1noatime 3. 文件系统优化（分业务）1禁止ext3、ext4日志功能*(针对数据不太重要的业务)* 4. 设置block的大小，一般为4K（应用场景一般为写入文件比较大，又比较频繁的场景）1mkfs -t ext3 -b 4096 /dev/sda1 5. 锁定系统的关键文件1chattr +/-i /etc/passwd 6. linux系统的内核调优（参数调优略）7. 设置开机的提示信息，以及系统信息1/etc/motd /etc/issue 8. 搭建系统的yum源，以及进行优化（upgrade）1/etc/yum.repos.d/ 9. 时间同步；服务器在50-100台之间可以搭建时间同步服务器ntpserver1/usr/sbin/ntpdate time.windows.com 10. 设置系统的字符集1/etc/sysconfig/i18n 11. 利用sudo工具来对用户进行集权管理1visudo 12. 限制ssh的登录设置，比如更改端口，禁止root登录，禁止无密码登录等等。1/etc/ssh/sshd.conf 13. 增大文件描述符1echo '* - nofile 65535 ' &gt;&gt;/etc/security/limits.conf 14. 定时清理/var/spool/clientsqueue/1写脚本，放在定时任务里面定时清理 15. 精简开机启动服务1234567a) setup,勾选开机启动的服务b) 终端输入ntsysvc) 脚本编写cat /server/scripts/chkinfo.sh#setup sys start server or processfor i in `chkconfig --list |grep 3:on|awk '&#123;print $1&#125;'`;do chkconfig --level 3 $i off;done/bin/sh /server/scripts/chkinfo.sh 以上优化为我经常使用的centos系统初始化过程。一般都是脚本自动化，脚本请戳StartOptimization.sh]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 面试题摘选(1)]]></title>
    <url>%2F2016%2F06%2F15%2Fpython-exercise%2F</url>
    <content type="text"><![CDATA[1. 请写出以下逻辑表达式的值 Logical operator precedence 123456789101112False and None# Answer: False0 and None or () and []# Answer: ()True and None or () and []# Answer: ()0 or None and () or []# Answer: []True or None and () or []# Answer: True1 or None and 'a' or 'b'# Answer: 1 2. 有多少个三位整数能被17整除? 将之输出 for..xrange + counter 123456bgnb = 0for item in xrange(100, 1000): if not item % 17: print '&#123;0&#125; / 17 = &#123;1&#125;'.format(item, item / 17) bgnb += 1print '能被17整除的三位数有&#123;0&#125;个'.format(bgnb) list comprehensions 1234ovlist = [x for x in xrange(100, 1000) if not x % 17]print '能被17整除的三位数有&#123;0&#125;个'.format(len(ovlist))for item in ovlist: print item 3. 循环崁套的方式计算连续整数之和,要求输出结果如下。如果输入数5,输出连续5个 数字之和:1 = 11+2 = 31+2+3 = 61+2+3+4 = 101+2+3+4+5 = 15 Cycle Counting 12345678910111213141516171819import sysif __name__ == "__main__": print 'Please input a int:' n = int(raw_input('&gt; ')) i = 1 s = 0 while i &lt;= n: j = 1 while j &lt;= i: if j &lt; i: sys.stdout.write(str(j)) sys.stdout.write('+') else: sys.stdout.write(str(j)) s += j print (" " + '= &#123;0&#125;'.format(s)) j += 1 i += 1 4. 限定 while 循环和print语句输出以下样式 样式 :样式一:112123123412345123456 样式二:123456123451234123121 样式三: 1 21 321 4321 54321654321 loop muli 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 样式一 while printprint '样式一'.center(30,'=')print '&gt; while print loop'n = 6i = 1while i &lt;= n: j = 1 while j &lt;= i: sys.stdout.write(str(j)) j += 1 print i += 1# 样式一 for loop printprint '&gt; for print loop'n = 6for i in range(1, n+1): for j in range(1, i+1): sys.stdout.write(str(j)) print# 样式二 while printprint '样式二'.center(30,'=')print '&gt; while print loop'n = 6i = 1while i &lt;= n: j = 1 while j + i &lt;= n + 1: sys.stdout.write(str(j)) j += 1 print i += 1# 样式二 for printprint '&gt; for print loop'n = 6for i in range(1, n+1): for j in range(1, n + 1 - i + 1): sys.stdout.write(str(j)) print# 样式三 while printprint '样式三'.center(30,'=')print '&gt; while print loop'n = 6i = 1while i &lt;= n: j = i c = 0 while c &lt; n - i: sys.stdout.write(' ') c += 1 while j &gt; 0: sys.stdout.write(str(j)) j -= 1 print i += 1## # 样式三 for printprint '&gt; for print loop'n = 6for i in range(1, n+1): for c in range(0, n - i): sys.stdout.write(' ') for j in range(i, 0, -1): sys.stdout.write(str(j)) print]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开通...]]></title>
    <url>%2F2016%2F06%2F12%2Fblog-begin%2F</url>
    <content type="text"><![CDATA[2016年06月12日 我的博客开通了 万网买的域名(便宜)，用dnspod做解析(解析给力)。 博客主要更新 技术大杂烩 生活小随笔(专栏未开)]]></content>
      <tags>
        <tag>self_note</tag>
      </tags>
  </entry>
</search>
